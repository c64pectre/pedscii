;    PEDSCII: Editor for the Commodore.
;    Copyright (C) 2025  C64PECTRE
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see https://www.gnu.org/licenses/.
;
;    Contact: https://github.com/c64pectre/pedscii/ create an issue

;;; summary: Main
;;; does-not-throw:
;;; notes:
;;;   Stack:
;;;     | F4 | F5 F6      | F7 F8 | F9 FA FB FC FD FE FF |
;;;     | __ | 1E 08      | 46 E1 | E9 A7 A7 79 A6 9C E3 |
;;;     |    | ENTRYPOINT | KERNAL|
.proc main
    jsr INITIALIZE

    from_loop OUTER_LOOP
        ldy CURSOR_SCREEN_X
        lda [ZPKERNAL_PNT],y
        pha
            jsr REVERSE_CURSOR_CHAR
            from_loop INNER_LOOP
                tya
                pha
                    jsr KERNAL_GETIN
                    bne _end                            ; break ; We've got a char
                    jsr L2017
                pla
                tay
                lda ZPKERNAL_TIME_2
                sec
                sbc PREVIOUS_ZPKERNAL_TIME_2
    ;>>++
    clv
    ;<<++
                cmp # CURSOR_BLINK_DELAY
                if_pl_then
                    jsr REVERSE_CURSOR_CHAR
                else_end
            next
                ;jmp _loop
                bvc _loop                                   ; bra
                brk
            end

            ; We've got a char in A
            tax
            pla
            tay
        pla
        sta [ZPKERNAL_PNT],y
        txa
        try
            jsr PROCESS_CHAR                                ; in: A | throws: EXCEPTION
           ;bvs _catch                                      ; Exception
            bvc _end                                        ; No exception
        catch
            ; check V=1
            jsr HANDLE_EXCEPTION                            ; in: ZP_EXCEPTION_CODE | out: V=0
            ; check V=0
        finally_end
    next
        ;jmp _loop
        bvc _loop                                           ; bra
        brk
    end

    ; Does not come here
.endproc

;;; summary reverse character under cursor
;;; changed: A
.proc REVERSE_CURSOR_CHAR
    lda [ZPKERNAL_PNT],y
    eor # $80
    sta [ZPKERNAL_PNT],y
    lda ZPKERNAL_TIME_2
    sta PREVIOUS_ZPKERNAL_TIME_2

    rts
.endproc

;;; summary: Add character in A to current cursor position, afterwards move 1 position to the right
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: A, X
.proc ADD_CHAR
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end

    ; G_MODE = MODE_EDIT

    cmp # PETSCII_NO_BREAK_SPACE
    if_eq_then
        lda # PETSCII_SPACE
    else_end

    ldx Z92
    cpx # MAX_LINE_LENGTH - 1
    if_eq_then
        rts
    else_end

    ldx CURRENT_BUFFER_COLUMN
    cpx P36
    if_cc_then
        rts
    else_end

    jsr L1AE4                                               ; May throw EXCEPTION_OUT_OF_MEMORY
    if_cs_then
        rts
    else_end
    
    jsr L1B9C
    ldx CURRENT_BUFFER_COLUMN
    inx
    stx CURRENT_BUFFER_COLUMN
    stx P19
    inc Z92
    jsr L1BBC
    if_cs_then
        lda # PETSCII_RETURN
        jsr L1AE4                                           ; May throw EXCEPTION_OUT_OF_MEMORY
        if_cs_then
            jsr L1C99                                       ; A- X- Y-
            jsr L1BF7
            rts
        else
            inc CURSOR_SCREEN_X
            jsr L1BCB
            jsr L1982
            lda CURRENT_BUFFER_B
            sta V37D4
            lda CURRENT_BUFFER_C
            sta V37D5
            jsr L1BD6
            inc V37D6
            jsr L219D

            rts
        end
    else
        lda CURSOR_SCREEN_X
        cmp # BUMP_RIGHT
        if_cs_then
            inc P36
            jsr SCROLL_RIGHT
            jsr L1A15
            rts
        else
            inc CURSOR_SCREEN_X
            jsr L1A15
            rts
        end
    end

    ; Does not come here
    brk
.endproc

;;; summary: Command: Delete (BACKSPACE)
;;; summary: A+ ...
.proc CMD_DELETE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end

    ; G_MODE = MODE_EDIT

    lda CURRENT_BUFFER_COLUMN
    cmp P36
    if_cc_then
        rts
    else_end
    
    jsr L1C99                                               ; A- X- Y-
    if_cs_then
        rts
    else_end
    
    jsr L1BBC
    cmp # PETSCII_RETURN
    if_ne_then
        jsr L1BF7
        dec CURRENT_BUFFER_COLUMN
        lda CURRENT_BUFFER_COLUMN
        sta P19
        dec Z92
        jsr L19FD
        jsr L1A15
        jsr L19D0
        inx
        cpx CURSOR_SCREEN_X
        if_ne_then
            dec P36
            jsr SCROLL_LEFT
            rts
        else_end
        dec CURSOR_SCREEN_X

        rts
    else_end

    jsr L1BCB
    jsr L1B9C
    jsr L19DD
    jsr L1982
    stx V3781
    jsr L1982
    jsr L1BD6
    txa
    clc
    adc V3781
    ;>>++
    clv
    ;<<++
    if_cs_then
        jsr L1B9C
        rts
    else_end

    cmp # MAX_LINE_LENGTH
    if_cs_then
        jsr L1B9C
        rts
    else_end

    jsr L1B9C
    jsr L1BBC
    if_cs_then
        jsr L1C99                                           ; A- X- Y-
        jsr L1C99                                           ; A- X- Y-
        if_cc_then
            jsr L1BBC
            cmp # PETSCII_RETURN
            if_ne_then
                jsr L1B9C
                jsr L1B9C                                   ; TODO Why twice?
                rts
            else_end

            jsr L1B9C
        else_end

        ;jmp _end
        bvc _end                                            ; bra
        brk
    else
        jsr L1C99                                           ; A- X- Y-
    end

    lda CURRENT_BUFFER_LINE_LO
    if_eq_then
        dec CURRENT_BUFFER_LINE_HI
    else_end

    dec CURRENT_BUFFER_LINE_LO
    jsr L1BF7
    lda # BUMP_RIGHT
    sta CURSOR_SCREEN_X
    lda T5A
    cmp # PETSCII_RETURN
    if_cs_then
        jsr L2627
        jsr MOVE_CURSOR_UP                                  ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
        jsr L219D
        rts
    else_end

    jsr L268E
    if_cs_then
        jsr L2627
        jsr MOVE_CURSOR_UP                                  ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
    else_end

    jsr L219D

    rts
.endproc

;;; summary: ?
;;; return:
;;;   C=0  OK
;;;   C=1  Fail
;;; changed: X+ ...
.proc L1982
    ldx # 0                                                 ; ???
    jsr L1BBC
    if_cs_then
        rts
    else_end

    from_loop
        cmp # PETSCII_RETURN
        beq _end                                            ; break
        inx
        jsr L1B9C
        jsr L1BBC
    next
        ;jmp _loop
        bvc _loop                                           ; bra
        brk
    end

    jsr L1B9C
    clc

    rts
.endproc

;;; summary: ?
;;; changed: A+ X+ Y+ ...
.proc L199D
    lda # <EDIT_PANEL_LAST_LINE_START_VM
    sta TFB
    lda # >EDIT_PANEL_LAST_LINE_START_VM
    sta TFC
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda L1CE8
        if_mi_then
            lda # EDIT_PANEL_LAST_LINE
            sec
            sbc T5A
    ;>>++
    ;clv
    ;<<++
            clc
            adc L1CE7
    ;>>++
    ;clv
    ;<<++
            lda # 0
            adc L1CE8
    ;>>++
    clv
    ;<<++
            if_mi_then
                lda # $80
                sta L2340
            else_end
        else_end
    else_end

    ldx V37D4
    ldy V37D5
    jsr L2290
    jsr L22B8

    rts
.endproc

;;; summary: ?
;;; changed: X+ ...
.proc L19D0
    jsr L1BCB
    jsr L1B9C
    jsr L19DD
    dex
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; out:
;;;   C=0  OK
;;;   C=1  Fail
;;;   X    ?
;;; changed: ...
.proc L19DD
    ldx # 0                                                 ; X = 0
    jsr L1C99                                               ; A- X- Y-
    if_cs_then
        rts                                                 ; Fail
    else_end

    inx                                                     ; X = 1
    from_loop
        jsr L1C99                                           ; A- X- Y-
        if_cs_then
            clc
            rts
        else_end

        jsr L1BBC
        cmp # PETSCII_RETURN
        beq _end                                            ; break
    next
        inx
        ;jmp _loop
        bvc _loop                                           ; bra
        brk
    end

    jsr L1B9C                                               ; A- X- Y-
    clc                                                     ; OK

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L19FD
    try
        jsr L1BCB
        from_loop
            jsr L1C99                                       ; A- X- Y-
            bcs _catch                                      ; throw
            jsr L1BBC
            cmp # PETSCII_RETURN
        next
            bne _loop
        end

        jsr L1B9C
    catch_finally_end

    jsr L1BE1
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1A15
    lda ZPKERNAL_PNT_LO
    sta TFB
    lda ZPKERNAL_PNT_HI
    sta TFC
    ldx T58
    ldy T59
    jsr L2290
    jsr L22B8
    jsr L2545

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1A2A
    try
        lda # 0
        sta CURSOR_SCREEN_X
        sta CURRENT_BUFFER_COLUMN
        jsr L1BEC
        ldy # 0
        inx
        from_loop
            cpy P36
            beq _end                                        ; break
            dex
            beq _catch
            jsr L1BBC
            bcs _catch
            cmp # PETSCII_RETURN
            beq _catch
            iny
            jsr L1B9C
            inc CURRENT_BUFFER_COLUMN
        next
            ;jmp _loop
            bvc _loop                                       ; bra
            brk
        end

        from_loop
            dex
            beq _end
            jsr L1BBC
            bcs _catch
            cmp # PETSCII_RETURN
            beq _catch
            iny
            jsr L1B9C
        next
            inc CURSOR_SCREEN_X
            inc CURRENT_BUFFER_COLUMN
            ;jmp _loop
            bvc _loop                                       ; bra
            brk
        else_end

        jsr L1BCB
        from_loop
            jsr L1BBC
            bcs _end                                        ; break
            cmp # PETSCII_RETURN
            beq _end                                        ; break
            iny
            jsr L1B9C
        next
            ;jmp _loop
            bvc _loop                                       ; bra
            brk
        end                                                 ; L1A79:

        jsr L1BD6
    catch_finally_end

    sty Z92

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1A7F
    lda # 0
    sta T5C
    ldx # >STATUS_COMMAND_PANEL_FIRST_LINE_START_CR
    ldy # <STATUS_COMMAND_PANEL_FIRST_LINE_START_CR
    ;jmp L1A9B
    bvc L1A9B                                               ; bra
    brk
.endproc

;;; summary: Setup colors
;;; changed: ...
.proc L1A89
    ;>>
    ;--lda # COLOR_DGY
    ;--sta VIC_EC
    ;--lda # COLOR_GRY
    ;--sta VIC_B0C
    ;<<
    ldx # >OUR_COLOR_RAM_BASE
    ldy # <OUR_COLOR_RAM_BASE
    sty T5C
    ;--lda #COLOR_WHT
    lda KVAR_COLOR
.endproc

;;; summary: ?
;;; changed: ...
.proc L1A9B
    from_loop   
        stx T5D
        from_loop
            cpy # <STATUS_COMMAND_PANEL_FIRST_LINE_START_CR
            if_eq_then
                cpx # >STATUS_COMMAND_PANEL_FIRST_LINE_START_CR
                if_eq_then
                    ;--lda # COLOR_BLK               ; Command color
                else_end
            else_end
            sta [T5C],y
        next
            iny
            bne _loop
        end
    next
        inx
        cpx # >(OUR_COLOR_RAM_BASE + OUR_COLOR_RAM_SIZE)
        bne _loop
    end

    rts
.endproc

;;; summary: Move cursor down
;;; changed: A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
.proc MOVE_CURSOR_DOWN
    lda ZPKERNAL_PNT_LO
    clc
    adc # OUR_SCREEN_WIDTH
    sta ZPKERNAL_PNT_LO
    lda ZPKERNAL_PNT_HI
    adc # 0
    ;>>++
    clv
    ;<<++
    sta ZPKERNAL_PNT_HI
    inc T5A

    rts
.endproc

;;; summary: Move cursor up
;;; changed: A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
.proc MOVE_CURSOR_UP
    lda ZPKERNAL_PNT_LO
    sec
    sbc # OUR_SCREEN_WIDTH
    ;>>++
    ;clv
    ;<<++
    sta ZPKERNAL_PNT_LO
    lda ZPKERNAL_PNT_HI
    sbc # 0
    ;>>++
    clv
    ;<<++
    sta ZPKERNAL_PNT_HI
    dec T5A

    rts
.endproc

;;; summary: Clear the last edit panel line
;;; changed: ...
.proc CLEAR_EDIT_PANEL_LAST_LINE
    ldx # <EDIT_PANEL_LAST_LINE_START_VM
    ldy # >EDIT_PANEL_LAST_LINE_START_VM
    stx T5C
    sty T5D
    from
        lda # PETSCII_SPACE
        ldy # OUR_SCREEN_WIDTH - 1
    loop
        sta [T5C],y
    next
        dey
        bpl _loop
    end

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: A+ X? Y- ...
.proc L1AE4
    sta L1B46
    tya
    pha
        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        lda [T4E],y                                         ; A = T4E.POINTER
        cmp # BLOCK_OFFSET_POINTER_MAX_VALUE                ; A ? BLOCK_OFFSET_POINTER_MAX_VALUE
        if_eq_then
            ; A = T4E.POINTER = BLOCK_OFFSET_POINTER_MAX_VALUE = $FF
            jsr L1B77                                       ; May throw EXCEPTION_OUT_OF_MEMORY
            if_cs_then
                ; Fail
                pla
                rts
            else_end

            sta L1B47
        else_end

        lda V37D4
        cmp CURRENT_BUFFER_B
        if_eq_then
            inc V37D5
        else_end

        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        lda [T4E],y                                         ; A = T4E.POINTER
        tay                                                 ; Y = A = T4E.POINTER
        iny                                                 ; Y = A + 1 = T4E.POINTER + 1
        from_loop
            dey
            lda [T4E],y
            iny
            if_eq_then
                ; Y = 0
                jsr L1B48
                ldy V37D5
                if_eq_then
                    lda T23
                    sta V37D4
                    lda # BLOCK_OFFSET_POINTER_MIN_VALUE
                    sta V37D5
                else_end

                ldy # 0
                ;jmp _end
                beq _end                                    ; bra
                brk
            else
                sta [T4E],y
            end
        next
            dey
            cpy CURRENT_BUFFER_C
            bne _loop
        end

        lda L1B46
        sta [T4E],y
        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        lda [T4E],y                                         ; A = T4E.POINTER
        clc
        adc # 1
    ;>>++
    clv
    ;<<++
        if_ne_then
            sta [T4E],y
        else_end
    pla
    tay
    lda L1B46
    clc                                                     ; OK

    rts
.endproc

;;; summary: ?
;;; in:
;;;   A  ?
;;;   Y = 0 = BLOCK_OFFSET_NEXT
;;; changed: ...
.proc L1B48
    ; Y = 0 = BLOCK_OFFSET_NEXT
    pha
        lda [T4E],y                                         ; A = T4E.NEXT
        pha
            if_ne_then
                ; A = T4E._NEXT != BLOCK_NONE
                ; Have next block
                sta T23                                     ; T23 = A = T4E._NEXT != BLOCK_NONE
                lda L1B47
                iny                                         ; Y = 1 = BLOCK_OFFSET_PREVIOUS
                sta [T22],y                                 ; T22.PREVIOUS = L1B47
                dey                                         ; Y = 0 = BLOCK_OFFSET_NEXT
                ;jmp _end
                beq _end                                    ; bra
                brk
            else
                lda L1B47
            end
            ; Y = 0 = BLOCK_OFFSET_NEXT
            
            sta [T4E],y                                     ; Y = 0 = BLOCK_OFFSET_NEXT
            sta T23
            lda [T22],y                                     ; Y = 0 = BLOCK_OFFSET_NEXT
            sta ZP_0E
        pla
        sta [T22],y                                         ; Y = 0 = BLOCK_OFFSET_NEXT
        lda CURRENT_BUFFER_B
        iny                                                 ; Y = 1 = BLOCK_OFFSET_PREVIOUS
        sta [T22],y                                         ; Y = 1 = BLOCK_OFFSET_PREVIOUS
        lda # BLOCK_OFFSET_POINTER_MIN_VALUE
        iny                                                 ; Y = 2 = BLOCK_OFFSET_POINTER
        sta [T22],y                                         ; Y = 2 = BLOCK_OFFSET_POINTER
    pla
    iny                                                     ; Y = 3 = BLOCK_OFFSET_POINTER_MIN_VALUE
    sta [T22],y

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc L1B77
    clc
    lda ZP_0E
    if_eq_then
        from_loop
            jsr L2017
        next
            bcs _loop
        end

        lda ZP_0E
        if_eq_then
            ; Show "out of memory"
            ldx # <RESOURCE_STRING_EXCEPTION_OUT_OF_MEMORY
            ldy # >RESOURCE_STRING_EXCEPTION_OUT_OF_MEMORY
            jsr PRINT_STATUS_LINE
            sec
        else_end
    else_end
    
    rts
.endproc

;;; summary:
;;; changed: A- X- Y-
.proc L1B9C
    pha
        tya
        pha
            lda CURRENT_BUFFER_C
            ldy # BLOCK_OFFSET_POINTER                      ; Y = 2 = BLOCK_OFFSET_POINTER
            cmp [T4E],y                                     ; A ? T4E.POINTER
            if_cs_then
                ; A >= T4E.POINTER
                ldy # BLOCK_OFFSET_NEXT                     ; Y = 0 = BLOCK_OFFSET_NEXT
                lda [T4E],y                                 ; A = T4E.NEXT
                if_ne_then
                    ; A = T4E.NEXT != BLOCK_NONE = 0
                    ; We have a next block
                    sta CURRENT_BUFFER_B
                    lda # BLOCK_OFFSET_POINTER_MIN_VALUE
                    sta CURRENT_BUFFER_C
                else_end

                ;jmp _end
                bvc _end                                    ; bra
                brk
            else
                inc CURRENT_BUFFER_C
            end
        pla
        tay
    pla

    rts
.endproc

;;; summary: C:= [T4E],CURRENT_BUFFER_C == 0
;;; changed: A+
.proc L1BBC
    sty L1B46                                               ; Backup Y
    ldy CURRENT_BUFFER_C
    lda [T4E],y
    clc
    if_eq_then
        sec
    else_end
    ldy L1B46                                               ; Restore Y

    rts
.endproc

;;; summary: T52#T53 := CURRENT_BUFFER_B#CURRENT_BUFFER_C
;;; changed: A- X- Y- T52:=CURRENT_BUFFER_B T53:=CURRENT_BUFFER_C
.proc L1BCB
    pha
        lda CURRENT_BUFFER_B
        sta T52
        lda CURRENT_BUFFER_C
        sta T53
    pla

    rts
.endproc

;;; summary: CURRENT_BUFFER_B#CURRENT_BUFFER_C := T52#T53
;;; changed: A- X- Y-
.proc L1BD6
    pha
        lda T52
        sta CURRENT_BUFFER_B
        lda T53
        sta CURRENT_BUFFER_C
    pla

    rts
.endproc

;;; summary: T58#T59 := CURRENT_BUFFER_B#CURRENT_BUFFER_C 
;;; changed: A- X- Y-
.proc L1BE1
    pha
        lda CURRENT_BUFFER_B
        sta T58
        lda CURRENT_BUFFER_C
        sta T59
    pla

    rts
.endproc

;;; summary: CURRENT_BUFFER_B#CURRENT_BUFFER_C := T58#T59
;;; changed: A- X- Y-
.proc L1BEC
    pha
        lda T58
        sta CURRENT_BUFFER_B
        lda T59
        sta CURRENT_BUFFER_C
    pla

    rts
.endproc

;;; summary: ?
;;; changed: A- X- Y-
.proc L1BF7
    pha
        txa
        pha
            tya
            pha
                lda V37D4
                cmp CURRENT_BUFFER_B
                if_eq_then
                    dec V37D5
                else_end

                ldy # BLOCK_OFFSET_POINTER                  ; Y = BLOCK_OFFSET_POINTER = 2
                lda [T4E],y                                 ; A = T4E.POINTER
                tax                                         ; X = A = T4E.POINTER
                cmp CURRENT_BUFFER_C
                if_eq_then
                    ; A = CURRENT_BUFFER_C = X = T4E.POINTER
                    lda [T4E],y                             ; A = T4E.POINTER ; Can remove this instruction?
                    sec
                    sbc # 1
    ;>>++
    clv
    ;<<++
                    sta [T4E],y
                    ldy CURRENT_BUFFER_B
                    jsr L1B9C
                    txa
                    cmp # BLOCK_OFFSET_POINTER_MIN_VALUE
                    if_eq_then
                        tya
                        jsr L1C55
                        ;jmp _end
                        bvc _end
                        brk
                    else
                        ldy # BLOCK_OFFSET_POINTER          ; Y = BLOCK_OFFSET_POINTER = 2
                        lda [T57],y                         ; A = T57.POINTER
                        cmp T59
                        if_cc_then
                            ldy # BLOCK_OFFSET_NEXT         ; Y = BLOCK_OFFSET_NEXT = 0
                            lda [T57],y                     ; A = T57.NEXT
                            sta T58
                            lda # BLOCK_OFFSET_POINTER_MIN_VALUE
                            sta T59
                        else_end
                    end

                    ;jmp _end
                    bvc _end                                ; bra
                    brk
                else
                    lda [T4E],y
                    sec
                    sbc # 1
    ;>>++
    clv
    ;<<++
                    sta [T4E],y
                    from
                        ldy CURRENT_BUFFER_C
                        iny
                    loop
                        lda [T4E],y
                        dey
                        sta [T4E],y
                    next
                        iny
                        iny
                        bne _loop
                    end
                end
            pla
            tay
        pla
        tax
    pla

    rts
.endproc

;;; summary: ?
;;; in:
;;;   A  ?
;;; changed: A- X+ Y+
.proc L1C55
    ldy # 0                                                 ; Y = BLOCK_OFFSET_NEXT = 0
    sta T23
    cmp V37D7
    if_eq_then
        ; A = V37D7
        lda [T22],y                                         ; A = T22.NEXT
        sta V37D7                                           ; V37D7 = A = T22.NEXT
        lda # BLOCK_OFFSET_POINTER_MIN_VALUE                ; A = BLOCK_OFFSET_POINTER_MIN_VALUE
        sta V37D8                                           ; V37D8 = A = BLOCK_OFFSET_POINTER_MIN_VALUE
    else_end

    lda [T22],y                                             ; A = T22.NEXT
    if_eq_then
        ; T22.NEXT = BLOCK_NONE
        iny                                                 ; Y = BLOCK_OFFSET_PREVIOUS = 1
        lda [T22],y                                         ; A = T22.PREVIOUS
        ;jmp _end
        bvc _end                                            ; bra
        brk
    else
        ; T22.NEXT != BLOCK_NONE
        sta T27
        iny                                                 ; Y = BLOCK_OFFSET_PREVIOUS = 1
        lda [T22],y                                         ; A = T22.PREVIOUS
        sta [T26],y                                         ; T26.PREVIOUS = T22.PREVIOUS = A
    end
    ; Y = BLOCK_OFFSET_PREVIOUS = 1

    ; A = previous block, if any.

    if_eq_then
        ; No previous block
        lda T27
        sta CURRENT_BUFFER_HEAD
        ldx CURRENT_BUFFER_INDEX
        sta BUFFER_TABLE_HEAD,x
        ;jmp _end
        bvc _end                                            ; bra
        brk
    else
        ; Have previous block
        sta T27
        dey                                                 ; Y = BLOCK_OFFSET_NEXT = 0
        lda [T22],y                                         ; A = T22.NEXT
        sta [T26],y                                         ; T26.NEXT = T22.NEXT = A
    end

    lda ZP_0E                                               ; A = ZP_0E
    ldy # BLOCK_OFFSET_NEXT                                 ; Y = BLOCK_OFFSET_NEXT = 0
    sta [T22],y                                             ; T22.NEXT = A = ZP_0E
    lda T23                                                 ; A = T23
    sta ZP_0E                                               ; ZP_0E = A = T23

    rts
.endproc

;;; summary: ?
;;; out:
;;;   C=0  OK
;;;   C=1  Fail
;;; changed: A- X- Y-
.proc L1C99
    pha
        tya
        pha
            lda CURRENT_BUFFER_C                            ; A = CURRENT_BUFFER_C
            cmp # BLOCK_OFFSET_POINTER_MIN_VALUE            ; (A = CURRENT_BUFFER_C) ? BLOCK_OFFSET_POINTER_MIN_VALUE
            if_eq_then
                ; A = CURRENT_BUFFER_C = BLOCK_OFFSET_POINTER_MIN_VALUE
                ldy # BLOCK_OFFSET_PREVIOUS                 ; Y = 1 = BLOCK_OFFSET_PREVIOUS
                lda [T4E],y                                 ; A = T4E.PREVIOUS
                if_eq_then
                    ; A = T4E.PREVIOUS = 0 = BLOCK_NONE
                    sec                                     ; Fail
                    bcs _end                                ; bra
                else
                    ; (A = T4E.PREVIOUS) != (0 = BLOCK_NONE)
                    sta CURRENT_BUFFER_B
                    iny                                     ; Y = 2 = BLOCK_OFFSET_POINTER
                    lda [T4E],y                             ; A = T4E.POINTER
                    sta CURRENT_BUFFER_C                    ; CURRENT_BUFFER_C = A = T4E.POINTER
                    clc                                     ; OK
                end

                ;jmp _end
                bvc _end                                    ; bra
                brk
            else
                dec CURRENT_BUFFER_C
                clc                                         ; OK
            end
        pla
        tay
    pla

    rts
.endproc

;;; summary: Command: Enter select mode for cut
;;; changed: ...
.proc CMD_SELECT_MODE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        ; End select mode, back to edit mode
        inc G_MODE
        ; G_MODE = MODE_EDIT
        jsr L219D

        rts
    else_end

    ; check G_MODE = MODE_EDIT

    jsr L1BBC
    if_cc_then
        dec G_MODE
        ; G_MODE = MODE_SELECT
        jsr L219D
        lda T58
        sta L1CE5
        lda T59
        sta L1CE6
        lda # 0
        sta L1CE7
        sta L1CE8
    else_end

    rts
.endproc

;;; summary: Command: Cut
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc CMD_CUT
    bit G_MODE
    if_pl_then
        ; G_MODE = MODE_EDIT
        rts
    else_end

    ; G_MODE = MODE_SELECT

    inc G_MODE
    ; G_MODE = MODE_EDIT

    lda # 1
    jsr L26DA
    lda # 0
    sta TFB
    sta PFD
    jsr L1B77                                               ; May throw EXCEPTION_OUT_OF_MEMORY
    if_cs_then
        rts
    else_end
    
    sta L1EE6
    sta TFC
    ldy # BLOCK_OFFSET_NEXT                                 ; Y = BLOCK_OFFSET_NEXT = 2
    lda [TFB],y                                             ; A = TFB.NEXT
    sta ZP_0E                                               ; ZP_0E = A = TFB.NEXT
    jsr L1B77                                               ; May throw EXCEPTION_OUT_OF_MEMORY
    if_cs_then
        lda L1EE6
        sta ZP_0E
        rts
    else_end
    
    sta L1EE7
    jsr L1BCB
    lda L1CE8
    if_pl_then
        sta L1CEA
        lda L1CE7
        sta L1CE9
        lda L1CE5
        sta CURRENT_BUFFER_B
        lda L1CE6
        sta CURRENT_BUFFER_C
        lda T58
        sta V37D4
        lda T59
        sta V37D5
        ;jmp _end
        bvc _end
        brk
    else
        eor # $FF
        sta L1CEA
        lda L1CE7
        eor # $FF
        sta L1CE9
        inc L1CE9
        if_eq_then
            inc L1CEA
        else_end

        lda L1CE5
        sta CURRENT_BUFFER_B
        lda L1CE6
        sta CURRENT_BUFFER_C
        jsr L1982
        lda CURRENT_BUFFER_B
        sta V37D4
        lda CURRENT_BUFFER_C
        sta V37D5
        jsr L1BD6
        jsr L1982
    end

    lda L1CE8
    if_pl_then
        sec
        lda CURRENT_BUFFER_LINE_LO
        sbc L1CE9
;>>++
;clv
;<<++
        sta CURRENT_BUFFER_LINE_LO
        lda CURRENT_BUFFER_LINE_HI
        sbc L1CEA
;>>++
clv
;<<++
        sta CURRENT_BUFFER_LINE_HI
        ;jmp _end
        bvc _end
        brk
    else
        inc CURRENT_BUFFER_LINE_LO
        if_eq_then
            inc CURRENT_BUFFER_LINE_HI
        else_end
    end

    lda L1EE6
    sta TFC
    ldx # BUFFER_INDEX_PASTE
    sta BUFFER_TABLE_HEAD,x
    sta BUFFER_TABLE_B,x
    lda # BLOCK_OFFSET_POINTER_MIN_VALUE
    sta BUFFER_TABLE_C,x
    lda CURRENT_BUFFER_B
    cmp V37D4
    if_eq_then
        jsr L1E80
        rts
    else_end

    ldy # BLOCK_OFFSET_NEXT                                 ; Y = BLOCK_OFFSET_NEXT = 0
    lda L1EE7
    sta PFE                                                 ; PFE = L1EE7
    lda [PFD],y
    sta ZP_0E                                               ; ZP_0E = PFD.NEXT
    lda [T4E],y
    sta [TFB],y                                             ; TFB.NEXT = T4E.NEXT
    sta PFE                                                 ; PFE = TFB.NEXT = T4E.NEXT
    tya                                                     ; A = 0
    iny                                                     ; Y = BLOCK_OFFSET_PREVIOUS = 1
    sta [TFB],y                                             ; TFB.PREVIOUS = 0 = BLOCK_NONE
    lda TFC
    sta [PFD],y                                             ; PFD.PREVIOUS = TFC
    iny                                                     ; Y = BLOCK_OFFSET_POINTER = 2
    lda [T4E],y                                             ; A = T4E.POINTER
    sec
    sbc CURRENT_BUFFER_C                                    ; A = T4E.POINTER - CURRENT_BUFFER_C
;>>++
;clv
;<<++
    clc
    adc # BLOCK_OFFSET_POINTER_MIN_VALUE                    ; A = T4E.POINTER - CURRENT_BUFFER_C + BLOCK_OFFSET_POINTER_MIN_VALUE
;>>++
clv
;<<++
    sta [TFB],y                                             ; TFB.POINTER = T4E.POINTER - CURRENT_BUFFER_C + BLOCK_OFFSET_POINTER_MIN_VALUE
    ldy CURRENT_BUFFER_C                                    ; Y = CURRENT_BUFFER_C
    dey                                                     ; Y = CURRENT_BUFFER_C - 1
    sty L1EE3                                               ; L1EE3 = CURRENT_BUFFER_C - 1
    ldy # BLOCK_OFFSET_POINTER                              ; Y = BLOCK_OFFSET_POINTER = 2
    sty L1EE4                                               ; L1EE4 = Y = BLOCK_OFFSET_POINTER = 2
    from_loop
        inc L1EE3
        inc L1EE4
        ldy L1EE3
        lda [T4E],y
        ldy L1EE4
        sta [TFB],y
        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        lda [T4E],y                                         ; A = T4E.POINTER
        cmp L1EE3                                           ; (A = T4E.POINTER) ? L1EE3
    next
        bne _loop                                           ; (A = T4E.POINTER) != L1EE3 -> continue
    end
    ; (A = T4E.POINTER) = L1EE3

    lda L1EE7
    sta PFE
    lda V37D4
    sta TFC
    ; PFD.NEXT := TFB.NEXT
    ldy # BLOCK_OFFSET_NEXT                                 ; Y = BLOCK_OFFSET_NEXT = 0
    lda [TFB],y                                             ; A = TFB.NEXT
    sta [PFD],y                                             ; PFD.NEXT = TFB.NEXT = A

    ldy # BLOCK_OFFSET_POINTER                              ; Y = BLOCK_OFFSET_POINTER = 2
    lda [TFB],y                                             ; A = TFB.POINTER
    sec
    sbc V37D5                                               ; A = TFB.POINTER - V37D5
;>>++
;clv
;<<++
    clc
    adc # BLOCK_OFFSET_POINTER_MIN_VALUE                    ; A = TFB.POINTER - V37D5 + BLOCK_OFFSET_POINTER_MIN_VALUE
;>>++
clv
;<<++
    sta [PFD],y                                             ; PFD.POINTER = A = TFB.POINTER - V37D5 + BLOCK_OFFSET_POINTER_MIN_VALUE
    ldy V37D5
    dey
    sty L1EE3
    ldy # BLOCK_OFFSET_POINTER_MIN_VALUE - 1                ; Y = 2
    sty L1EE4
    from_loop
        inc L1EE3
        inc L1EE4
        ldy L1EE3
        lda [TFB],y
        ldy L1EE4
        sta [PFD],y
    next
        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        lda [TFB],y                                         ; A = TFB.POINTER
        cmp L1EE3                                           ; (A = TFB.POINTER) ? L1EE3
        bne _loop                                           ; (A = TFB.POINTER) != L1EE3 -> continue
    end
    ; A = TFB.POINTER = L1EE3

    ldy # BLOCK_OFFSET_POINTER                              ; Y = BLOCK_OFFSET_POINTER = 2
    lda V37D5                                               ; A = V37D5
    sta [TFB],y                                             ; TFB.POINTER = A = V37D5
    tay                                                     ; Y = A = V37D5
    lda # PETSCII_NUL                                       ; A = PETSCII_NUL = 0
    sta [TFB],y                                             ; TFB[V37D5] = A = PETSCII_NUL = 0
    tay                                                     ; Y = 0 = BLOCK_OFFSET_NEXT
    sta [TFB],y                                             ; TFB.NEXT = A = 0 = BLOCK_NONE
    ldy # BLOCK_OFFSET_PREVIOUS                             ; Y = BLOCK_OFFSET_PREVIOUS = 1
    lda CURRENT_BUFFER_B
    sta [PFD],y                                             ; PFD.PREVIOUS = A = CURRENT_BUFFER_B
    dey                                                     ; Y = BLOCK_OFFSET_NEXT = 0
    lda PFE                                                 ; A = PFE
    sta [T4E],y                                             ; T4E.NEXT = A = PFE
    lda [PFD],y                                             ; A = PFD.NEXT
    if_ne_then
        ; A = PFD.NEXT != BLOCK_NONE
        sta TFC                                             ; (TFC = A = PFD.NEXT) != BLOCK_NONE
        lda PFE                                             ; A = PFE
        iny                                                 ; Y = BLOCK_OFFSET_PREVIOUS = 1
        sta [TFB],y                                         ; TFB.PREVIOUS = A = PFE
    else_end

    lda CURRENT_BUFFER_C                                    ; A = CURRENT_BUFFER_C
    cmp # BLOCK_OFFSET_POINTER_MIN_VALUE                    ; (A = CURRENT_BUFFER_C) ? (BLOCK_OFFSET_POINTER_MIN_VALUE = 3)
    if_eq_then
        ; A = CURRENT_BUFFER_C = BLOCK_OFFSET_POINTER_MIN_VALUE = 3
        lda CURRENT_BUFFER_B
        jsr L1C55
        ;jmp _end
        bvc _end                                            ; bra
        brk
    else
        ; A = CURRENT_BUFFER_C != (BLOCK_OFFSET_POINTER_MIN_VALUE = 3)
        ; implies
        ; A = CURRENT_BUFFER_C > BLOCK_OFFSET_POINTER_MIN_VALUE = 3
        ; because is never decremented below BLOCK_OFFSET_POINTER_MIN_VALUE
        sec
        sbc # 1
;>>++
clv
;<<++
        ; A = CURRENT_BUFFER_C - 1 >=  BLOCK_OFFSET_POINTER_MIN_VALUE
        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        sta [T4E],y                                         ; T4E.POINTER = A = CURRENT_BUFFER_C - 1 >= BLOCK_OFFSET_POINTER_MIN_VALUE
    end

    lda PFE
    sta CURRENT_BUFFER_B
    lda # BLOCK_OFFSET_POINTER_MIN_VALUE                    ; A = BLOCK_OFFSET_POINTER_MIN_VALUE = 3
    sta CURRENT_BUFFER_C                                    ; CURRENT_BUFFER_C = A = BLOCK_OFFSET_POINTER_MIN_VALUE = 3
    jsr L21A2

    rts
.endproc

;;; summary: Command: Select all
.proc CMD_SELECT_ALL
    ; TODO
    rts
.endproc

;;; summary: Command: Copy
.proc CMD_COPY
    ; TODO
    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1E80
    from
        ldy CURRENT_BUFFER_C                                ; Y = CURRENT_BUFFER_C
        sty L1EE3                                           ; L1EE3 = Y = CURRENT_BUFFER_C
        ldy # BLOCK_OFFSET_POINTER_MIN_VALUE                ; Y = BLOCK_OFFSET_POINTER_MIN_VALUE = 3
        sty L1EE4                                           ; L1EE4 = Y = BLOCK_OFFSET_POINTER_MIN_VALUE = 3
    loop
        ldy L1EE3
        lda [T4E],y
        ldy L1EE4
        sta [TFB],y
        inc L1EE3
        inc L1EE4
        lda L1EE3
        cmp V37D5
        bne _loop
    end

    lda # 0                                                 ; A = BLOCK_NONE = 0
    tay                                                     ; Y = BLOCK_OFFSET_NEXT = 0
    sta [TFB],y                                             ; TFB.NEXT = A = BLOCK_NONE = 0
    iny                                                     ; Y = BLOCK_OFFSET_PREVIOUS = 1
    sta [TFB],y                                             ; TFB.PREVIOUS = A = BLOCK_NONE = 0
    lda L1EE4                                               ; A = L1EE4
    iny                                                     ; Y = BLOCK_OFFSET_POINTER = 2
    sta [TFB],y                                             ; TFB.POINTER = A = L1EE4
    tay                                                     ; Y = TFB.POINTER = A = L1EE4
    lda # PETSCII_NUL                                       ; A = PETSCII_NUL = 0
    sta [TFB],y                                             ; TFB[L1EE4] = A = PETSCII_NUL = 0

    from
        ldy V37D5
        dey
        sty L1EE3                                           ; L1EE3 = V37D5
        ldy CURRENT_BUFFER_C
        dey
        sty L1EE4                                           ; L1EE4 = CURRENT_BUFFER_C - 1
    loop
        inc L1EE3                                           ; L1EE3 = L1EE3' + 1
        inc L1EE4                                           ; L1EE4 = L1EE4' + 1
        ldy L1EE3                                           ; Y = L1EE3' + 1
        lda [T4E],y                                         ; A = T4E[L1EE3' + 1]
        ldy L1EE4                                           ; Y = L1EE4' + 1
        sta [T4E],y                                         ; T4E[L1EE4' + 1] = T4E[L1EE3' + 1]
        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        lda [T4E],y                                         ; A = T4E.POINTER
        cmp L1EE3                                           ; (A = T4E.POINTER) ? (L1EE3' + 1)
        bne _loop                                           ; (A = T4E.POINTER) != (L1EE3' + 1) -> continue
    end
    ; (A = T4E.POINTER) = (L1EE3' + 1)
    ; Y = BLOCK_OFFSET_POINTER = 2

    lda L1EE4
    sta [T4E],y                                             ; T4E.POINTER = A = L1EE4
    jsr L21A2

    rts
.endproc

;;; summary: Command: Paste
;;; throws: EXCEPTION_OUT_OF_MEMORY, EXCEPTION_NOT_ENOUGH_MEMORY
;;; changed: ...
.proc CMD_PASTE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end

    ; G_MODE = MODE_EDIT

    ldx # BUFFER_INDEX_PASTE                                ; 1
    lda BUFFER_TABLE_HEAD,x
    jsr L1FFE
    sta L1EE5
    inc L1EE5
    lda ZP_0E
    jsr L1FFE
    cmp L1EE5
    if_cc_then
        ; Show "not enough memory"
        ldx # <RESOURCE_STRING_EXCEPTION_NOT_ENOUGH_MEMORY
        ldy # >RESOURCE_STRING_EXCEPTION_NOT_ENOUGH_MEMORY
        jsr PRINT_STATUS_LINE
        rts
    else_end

    jsr L1BEC
    clc
    lda CURRENT_BUFFER_LINE_LO
    adc L1CE9
    sta CURRENT_BUFFER_LINE_LO
    lda CURRENT_BUFFER_LINE_HI
    adc L1CEA
;>>++
clv
;<<++
    sta CURRENT_BUFFER_LINE_HI
    lda # 0
    sta TFB
    sta PFD
    tay                                                     ; Y = BLOCK_OFFSET_NEXT = 0
    lda [T4E],y                                             ; A = T4E.NEXT
    pha
        lda CURRENT_BUFFER_B
        sta TFC
        ldx # BUFFER_INDEX_PASTE
        lda BUFFER_TABLE_HEAD,x
        if_eq_then
            ; Paste buffer has no head.
            pla
            rts
        else_end

        ; A = Head of Paste buffer != BLOCK_NONE
        from_loop
            sta PFE
            lda TFC
            pha
                jsr L1B77                                   ; May throw EXCEPTION_OUT_OF_MEMORY
                ldy # BLOCK_OFFSET_NEXT                     ; Y = BLOCK_OFFSET_NEXT = 0
                sta [TFB],y                                 ; TFB.NEXT = A
                sta TFC                                     ; TFC = A
                lda [TFB],y                                 ; A = TFB.NEXT
                sta ZP_0E                                   ; ZP_0E = A = TFB.NEXT
            pla
            iny                                             ; Y = BLOCK_OFFSET_PREVIOUS = 1
            sta [TFB],y                                     ; TFB.PREVIOUS = A
            ; Copy rest of block from PFD to TFB.
            from
                iny                                         ; Y = BLOCK_OFFSET_POINTER = 2       
            loop
                lda [PFD],y
                sta [TFB],y
            next
                iny
                bne _loop                                   ; Y != 0 -> continue
            end
            ; Y = 0
        next
            ; Y = 0 = BLOCK_OFFSET_NEXT
            lda [PFD],y                                     ; A = PFD.NEXT
            bne _loop                                       ; (A = PFD.NEXT) != (0 = BLOCK_NONE) -> continu
            ; (A = PFD.NEXT) = (0 = BLOCK_NONE)
        end
        ; (A = PFD.NEXT) = (0 = BLOCK_NONE)
        ; Y = 0 = BLOCK_OFFSET_NEXT

        lda TFC
        sta L1EE5
        jsr L1B77                                           ; May throw EXCEPTION_OUT_OF_MEMORY
        ldy # BLOCK_OFFSET_NEXT                             ; Y = BLOCK_OFFSET_NEXT = 0
        sta [TFB],y
        sta TFC
        lda [TFB],y
        sta ZP_0E
        lda L1EE5
        iny                                                 ; Y = BLOCK_OFFSET_PREVIOUS = 1
        sta [TFB],y                                         ; TFB.PREVIOUS = A = L1EE5
    pla                                                     ; A = T4E.NEXT
    dey                                                     ; Y = BLOCK_OFFSET_NEXT = 0
    sta [TFB],y                                             ; TFB.NEXT = A = T4E.NEXT
    cmp # BLOCK_NONE                                        ; (TFBA = .NEXT = T4E.NEXT) ? (BLOCK_NONE = 0)
    if_ne_then
        ; (A = TFB.NEXT = T4E.NEXT) != BLOCK_NONE
        ; Have next block
        sta PFE                                             ; (PFE = A = TFB.NEXT = T4E.NEXT) != BLOCK_NONE
        lda TFC                                             ; A = TFC
        iny                                                 ; Y = BLOCK_OFFSET_PREVIOUS = 1
        sta [PFD],y                                         ; PFD.PREVIOUS = A = TFC
    else_end

    from
        ldy CURRENT_BUFFER_C
        dey
        sty L1EE3
        ldy # BLOCK_OFFSET_POINTER_MIN_VALUE - 1            ; 2
        sty L1EE4
    loop
        inc L1EE3
        inc L1EE4
        ldy L1EE3
        lda [T4E],y
        ldy L1EE4
        sta [TFB],y
    next
        ldy # BLOCK_OFFSET_POINTER
        lda [T4E],y
        cmp L1EE3
        bne _loop
    end

    lda L1EE4
    sta [TFB],y
    lda CURRENT_BUFFER_C
    cmp # BLOCK_OFFSET_POINTER_MIN_VALUE
    if_eq_then
        lda CURRENT_BUFFER_B
        jsr L1C55
        ;jmp _end
        bvc _end
        brk
    else
        sec
        sbc # 1
;>>++
clv
;<<++
        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        sta [T4E],y                                         ; T4E.POINTER = A
    end

    lda TFC
    sta CURRENT_BUFFER_B
    lda # BLOCK_OFFSET_POINTER_MIN_VALUE
    sta CURRENT_BUFFER_C
    lda L1EE5
    sta PFE
    ldy # BLOCK_OFFSET_POINTER                              ; Y = BLOCK_OFFSET_POINTER = 2
    lda [PFD],y
    cmp # BLOCK_OFFSET_POINTER_MIN_VALUE
    if_eq_then
        lda PFE
        jsr L1C55
        ;jmp _end
        bvc _end
        brk
    else
        sec
        sbc # 1
;>>++
clv
;<<++
        sta [PFD],y                                         ; PFD.POINTER = A
    end

    lda T5A                                                 ; A = T5A
    cmp # BUMP_TOP - 1                                      ; (A = T5A) ? (BUMP_TOP - 1)
    if_lt_then
        ; (A = T5A) < (BUMP_TOP - 1)
        lda # BUMP_TOP - 1
        sta T5A                                             ; T5A = BUMP_TOP - 1
    else_end

    jsr L21A2

    rts
.endproc

;;; summary: List block count
;;; in:
;;;   A  Head block
;;; out:
;;;   A  Block count
;;; changed: A+ X+ Y+ TFB#TFC
.proc L1FFE
    ; Have head?
    cmp # BLOCK_NONE
    if_eq_then
        ; A = 0 = BLOCK_NONE
        ; No
        rts                                                 ; out: A = 0
    else_end
    ; A != 0

    sta TFC                                                 ; TFC = A
    lda # 0                                                 ; A = 0
    sta TFB                                                 ; TFB = A = 0
    tax                                                     ; X = A = 0 ; Counter
    tay                                                     ; Y = X = A = 0 = BLOCK_OFFSET_NEXT
    from_loop
        inx                                                 ; X = X' + 1
        lda [TFB],y                                         ; A = TFB.NEXT
        beq _end                                            ; A = TFB.NEXT = BLOCK_NONE -> break
        ; A = TFB.NEXT != BLOCK_NONE
        sta TFC                                             ; TFC = A = TFB.NEXT != BLOCK_NONE ; Go to next block
    next
        ;jmp _loop
        bne _loop                                           ; bra
        brk
    end

    txa

    rts                                                     ; out: A
.endproc

;;; summary: ?
;;; changed: A+ X+ Y+ T5C T5D T5E V3787 V3788 V3789 V378A V378B V3783
.proc L2017
    lda # 0
    sta T5C
    sta T5E
    sta V3787
    L2020:
    sta V3788
    sta V3789
    sta V378A
    sta V378B
    lda CURRENT_BUFFER_HEAD
    pha
    from_loop
        pla
        sta T5D
        ldy # BLOCK_OFFSET_NEXT
        lda [T5C],y
        if_eq_then
            clc
            rts
        else_end
    next
        pha
        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        lda [T5C],y                                         ; A = T5C.POINTER
        cmp # BLOCK_OFFSET_POINTER_MAX_VALUE
        beq _loop                                           ; BLock is full -> continue
    end

    sta V3783
    inc V3783
    pla
    sta T5F
    cmp CURRENT_BUFFER_B
    if_eq_then
        inc V3787
    else_end

    cmp T58
    if_eq_then
        inc V3788
    else_end

    cmp V37D7
    if_eq_then
        inc V3789
    else_end

    cmp V37D4
    if_eq_then
        inc V378A
    else_end

    cmp L1CE5
    if_eq_then
        inc V378B
    else_end

    from
        ldy # BLOCK_OFFSET_POINTER
        lda [T5E],y
        sta V3785
        ldy # BLOCK_OFFSET_POINTER_MIN_VALUE
        sty V3784
    loop
        ldy V3784
        lda [T5E],y
        ldy V3783
        sta [T5C],y
        lda V3787
        if_ne_then
            lda CURRENT_BUFFER_C
            cmp V3784
            if_eq_then
                lda T5D
                sta CURRENT_BUFFER_B
                sty CURRENT_BUFFER_C
                dec V3787
            else_end
        else_end

        lda V3788
        if_ne_then
            lda T59
            cmp V3784
            if_eq_then
                lda T5D
                sta T58
                sty T59
                dec V3788
            else_end
        else_end

        lda V3789
        if_ne_then
            lda V37D8
            cmp V3784
            if_eq_then
                lda T5D
                sta V37D7
                sty V37D8
                dec V3789
            else_end
        else_end

        lda V378A
        if_ne_then
            lda V37D5
            cmp V3784
            if_eq_then
                lda T5D
                sta V37D4
                sty V37D5
                dec V378A
            else_end
        else_end

        lda V378B
        if_ne_then
            lda L1CE6
            cmp V3784
            if_eq_then
                lda T5D
                sta L1CE5
                sty L1CE6
                dec V378B
            else_end
        else_end

        lda V3784
        cmp V3785
        if_eq_then
            lda T5F
            jsr L1C55                                       ; A- X+ Y+
            ldy # BLOCK_OFFSET_POINTER                      ; Y = BLOCK_OFFSET_POINTER = 2
            lda V3783
            sta [T5C],y                                     ; T5C.POINTER = V3783
            clc                                             ; OK
            rts
        else_end
    next
        inc V3784
        inc V3783
        beq _end
        jmp _loop                                           ; bne = bra not possible
    end

    from
        lda # BLOCK_OFFSET_POINTER_MAX_VALUE
        ldy # BLOCK_OFFSET_POINTER                          ; Y = BLOCK_OFFSET_POINTER = 2
        sta [T5C],y                                         ; T5X.POINTER = BLOCK_OFFSET_POINTER_MAX_VALUE
        iny                                                 ; Y = 3 = BLOCK_OFFSET_POINTER_MIN_VALUE
        sty V3783
        lda V3784
        sec
        sbc # BLOCK_OFFSET_POINTER_MIN_VALUE
;>>++
;clv
;<<++
        sta V3786
        inc V3785
        ldy V3784
    loop
        lda [T5E],y
        ldy V3783
        sta [T5E],y
    next
        inc V3783
        inc V3784
        ldy V3784
        cpy V3785
        bne _loop
    end

    lda V3787
    if_ne_then
        lda CURRENT_BUFFER_C
        sec
        sbc V3786
;>>++
;clv
;<<++
        sta CURRENT_BUFFER_C
    else_end

    lda V3788
    if_ne_then
        lda T59
        sec
        sbc V3786
;>>++
;clv
;<<++
        sta T59
    else_end

    lda V3789
    if_ne_then
        lda V37D8
        sec
        sbc V3786
;>>++
;clv
;<<++
        sta V37D8
    else_end

    lda V378A
    if_ne_then
        lda V37D5
        sec
        sbc V3786
;>>++
;clv
;<<++
        sta V37D5
    else_end

    lda V378B
    if_ne_then
        lda L1CE6
        sec
        sbc V3786
;>>++
;clv
;<<++
        sta L1CE6
    else_end

    lda V3785
    clc
    sbc V3786
;>>++
;clv
;<<++
    ldy # BLOCK_OFFSET_POINTER                              ; Y = BLOCK_OFFSET_POINTER = 2
    sta [T5E],y                                             ; T5E.POINTER = A
    sec                                                     ; Fail?

;>>++
clv
;<<++

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L219D
    lda # 0
    pha
    beq L21A5                                               ; bra
.endproc

;;; summary: ?
;;; changed: ...
.proc L21A2
    lda # 1
    pha
.endproc

;;; summary: ?
;;; changed: ...
.proc L21A5
    jsr L1BCB
    jsr L1BBC
    if_cc_then
        jsr L1B9C
        jsr L19DD
        dex
        ;jmp _end
        bvc _end
        brk
    else
        ldx # 0
    end

    stx CURRENT_BUFFER_COLUMN
    stx P19
    txa
    sec
    sbc CURSOR_SCREEN_X
;>>++
clv
;<<++
    if_cc_then
        lda CURRENT_BUFFER_COLUMN
        sta CURSOR_SCREEN_X
        lda # 0
    else_end

    sta P36
    jsr L1BE1
    jsr L1982
    stx Z92
    pla
    pha
    if_ne_then
        jsr L1BEC
        jsr L34FF
    else_end

    jsr L333B                                               ; A+ L3380+ L337F+
    lda # >OUR_COLOR_RAM_BASE
    sta TFB
    lda # >(OUR_VIDEO_MATRIX_BASE - 1)
    sta TFC
    lda # <(OUR_VIDEO_MATRIX_BASE - 1)
    sta PFE
    ldx V37D7
    ldy V37D8
    jsr L2290
    try
        from_loop
            lda TFB
            clc
            adc # OUR_SCREEN_WIDTH
;>>++
clv
;<<++
            sta TFB
            if_cs_then
                inc TFC
            else_end

            inc PFE
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                lda PFE
                cmp L337F
                if_cs_then
                    cmp L3380
                    if_cc_then
                        lda # $80
                        sta L2340
                    else_end
                else_end
            else_end

            jsr L22B8
            bcs _catch
        next
            lda PFE
            cmp # EDIT_PANEL_LAST_LINE
            bne _loop
        end

        clc
    catch_finally_end

    pla
    pha
        if_ne_then
            if_cc_then
                lda Z97
                sta CURRENT_BUFFER_B
                stx CURRENT_BUFFER_C
                jsr L19DD
                lda CURRENT_BUFFER_B
                sta V37D4
                lda CURRENT_BUFFER_C
                sta V37D5
                ;jmp _end
                bvc _end
                brk
            else
                lda Z97
                sta V37D4
                stx V37D5
            end

            lda PFE
            sta V37D6
        else_end

        from_loop
            lda PFE
            cmp # EDIT_PANEL_LAST_LINE
            beq _end                                        ; break
            clc
            lda TFB
            adc # OUR_SCREEN_WIDTH
;>>++
clv
;<<++
            sta TFB
            if_cs_then
                inc TFC
            else_end

            lda # PETSCII_SPACE
            ldy # OUR_SCREEN_WIDTH - 1
            from_loop
                sta [TFB],y
            next
                dey
                bpl _loop
            end
        next
            inc PFE
            ;jmp _loop
            bvc _loop
            brk
        end

        jsr L1BD6
    pla
    if_ne_then
        ; A != 0
        lda # 0
        sta ZPKERNAL_PNT_HI
        lda T5A
        asl
        asl
        adc T5A
        asl
        asl
        rol ZPKERNAL_PNT_HI
        asl
        rol ZPKERNAL_PNT_HI
        sta ZPKERNAL_PNT_LO
        lda ZPKERNAL_PNT_HI
        adc # >OUR_VIDEO_MATRIX_BASE
;>>++
clv
;<<++
        sta ZPKERNAL_PNT_HI
    else_end

    jsr L2545

    rts
.endproc

;;; summary: ?
;;; changed: A+ X=Y' Y=2
.proc L2290
    lda # 0
    sta T5C
    sta Z96

    stx T5D
    stx Z97

    tya
    tax
    ldy # BLOCK_OFFSET_POINTER
    lda [T5C],y
    sta V378C

    rts
.endproc

;;; summary: ?
;;; parameters:
;;;   X: ?
;;; return:
;;;   X: ?
;;; changed: ...
.proc L22B8
    ; Note: A & Y are free to use here.
    txa
    tay
    lda [Z96],y

    if_eq_then
        ; A == 0
        txa
        pha
            ; Show "[bottom]"
            ldx # <RESOURCE_STRING_BOTTOM
            ldy # >RESOURCE_STRING_BOTTOM
            jsr PRINT_FILL_LINE                             ; A+ X- Y+
        pla
        tax
        sec
        rts
    else_end
    
    ldy P36
    ;if_ne_then
        beq L22E6
        ;from_loop
            L22CE:
            sty Z9B
                txa
                tay
                lda [Z96],y
            ldy Z9B

            cmp # PETSCII_RETURN
            if_eq_then
                ldy # 0
                ;jmp L2319                                   ; break break
                bvc L2319
                brk
            else_end

            cpx V378C
            if_eq_then
                jsr L2341
            else_end
        ;next
            inx
            dey
            bne L22CE
        ;end
    ;else_end
    L22E6:

    ;from_loop
        sty Z9B
            txa
            tay
            lda [Z96],y
        ldy Z9B

        cmp # PETSCII_RETURN
        beq L2319                                           ; break
        cpy # OUR_SCREEN_WIDTH
        ;if_eq_then
            bne L2304
            ;from_loop
                L22F1:
                cpx V378C
                if_cs_then
                    jsr L2341
                else_end

                inx
                sty Z9B
                    txa
                    tay
                    lda [Z96],y
                ldy Z9B
            ;next
                cmp # PETSCII_RETURN
                bne L22F1
            ;end

            ;jmp L2319                                       ; break
            bvc L2319
            brk
        ;else
            L2304:
            jsr L240D                                       ; A+, V378D+
            eor L2340
            sta [TFB],y
            iny
            cpx V378C
            if_cs_then
                jsr L2341
            else_end
        ;end
    ;next
        inx
        ;jmp L22E6                                           ; _loop
        bvc L22E6
        brk
    ;end
    L2319:

    cpx V378C
    if_cs_then
        jsr L2341
    else_end

    inx
    from
        lda # PETSCII_SPACE
        eor L2340
    loop
        cpy # OUR_SCREEN_WIDTH
        beq _end                                            ; break
        sta [TFB],y
    next
        iny
        bne _loop
    end

    lda # 0
    sta L2340
    clc

    rts
.endproc

;;; summary: ?
;;; out:
;;;   X = 2
;;; changed:
;;;   A+  X=2  Y-
;;;   L22BA := L22D0 := L22E8 := L22FC := T5D := Z97 := [T5C],0
;;;   V378C := [T5C],2
.proc L2341
    tya
    pha
        ldy # BLOCK_OFFSET_NEXT
        lda [T5C],y
        sta T5D
        sta Z97

        ldy # BLOCK_OFFSET_POINTER
        lda [T5C],y
        sta V378C
        ldx # 2
    pla
    tay

    rts
.endproc

;;; summary: Print null terminated string in X#Y to T5C#T5D right fill the line with spaces.
;;; return:
;;;   Y: index 1 after character in line.
;;; changed: A+ X+ Y+ T5C+ T5D+
.proc PRINT_FILL_LINE
    from
        stx T5C
        sty T5D
        ldy # 0
    loop
        lda [T5C],y
        beq _end                                            ; PETSCII_NUL -> break
        jsr L240D                                           ; A+, V378D+
        sta [TFB],y
    next
        iny
        bne _loop                                           ; bra
    end

    tya
    pha
        from
            lda # PETSCII_SPACE
        loop
            cpy # OUR_SCREEN_WIDTH
            beq _end                                        ; break
            sta [TFB],y
        next
            iny
            bne _loop
        end
    pla
    tay

    rts
.endproc

;;; summary: Command: Split line (insert/add return)
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc CMD_SPLIT_LINE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end

    ; G_MODE = MODE_EDIT

    jsr L1AE4                                               ; May throw EXCEPTION_OUT_OF_MEMORY
    if_cs_then
        rts
    else_end

    jsr L1B9C
    lda T5A
    cmp # BUMP_BOTTOM
    if_cc_then
        jsr MOVE_CURSOR_DOWN                                ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
        jsr L2649
        ;jmp _end
        bvc _end
        brk
    else
        jsr L2671
    end

    lda # EDIT_PANEL_MIN_COLUMN
    sta CURSOR_SCREEN_X
    inc CURRENT_BUFFER_LINE_LO
    if_eq_then
        inc CURRENT_BUFFER_LINE_HI
    else_end

    jsr L219D

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L23B1
    lda # >OUR_VIDEO_MATRIX_BASE
    sta T5D
    sta T5F
    lda # <OUR_VIDEO_MATRIX_BASE
    sta T5C
    lda # OUR_SCREEN_WIDTH
    sta T5E
    ldx # EDIT_PANEL_LAST_LINE
    from_loop
        from
            ldy # OUR_SCREEN_WIDTH - 1
        loop
            lda [T5E],y
            sta [T5C],y
        next
            dey
            bpl _loop
        end

        lda T5F
        sta T5D
        lda T5E
        sta T5C
        clc
        adc # OUR_SCREEN_WIDTH
;>>++
clv
;<<++
        sta T5E
        if_cs_then
            inc T5F
        else_end
    next
        dex
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L23DF
    from
        lda # <EDIT_PANEL_LAST_LINE_START_VM
        sta T5C
        lda # <EDIT_PANEL_BEFORE_LAST_LINE_START_VM
        sta T5E
        lda # >EDIT_PANEL_LAST_LINE_START_VM
        sta T5D
        sta T5F
        ldx # EDIT_PANEL_LAST_LINE
    loop
        from
            ldy # OUR_SCREEN_WIDTH - 1
        loop
            lda [T5E],y
            sta [T5C],y
        next
            dey
            bpl _loop
        end

        lda T5F
        sta T5D
        lda T5E
        sta T5C
        clc
        adc # >OUR_COLOR_RAM_BASE
;>>++
clv
;<<++
        sta T5E
        if_cc_then
            dec T5F
        else_end
    next
        dex
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: A+, V378D+
.proc L240D
    pha
        and # $7F                                           ; Clear reverse bit?
        cmp # PETSCII_SPACE
        ; A < $20  -> C=0
        ; A >= $20 -> C=1
        ror V378D
    pla
    asl
    ror V378D
    asl
    asl V378D
    ror
    asl V378D
    ror
    eor # $80
    rts
.endproc

;;; summary: Get command text
;;; out: COMMAND_TEXT
;;; changed: A  X Y ...
.proc GET_COMMAND_TEXT
    lda # <STATUS_COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFB
    lda # >STATUS_COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFC
    jsr PRINT_FILL_LINE                                     ; A+ X- Y+
    from
        ldx # 0
    loop
        jsr L247D
        jsr L24E6                                           ; out A
        ; Backspace
        cmp # PETSCII_DELETE
        if_eq_then
            cpx # 0
            if_ne_then
                dex
                dey
                lda # PETSCII_SPACE
                sta [TFB],y
            else_end

            ;jmp _end
            bvc _end                                        ; bra
            brk
        else
            pha
            lda L24E5
            if_ne_then
                pla
                cmp # CMD_KEY_SEARCH_DOWN
                if_eq_then
                    sta COMMAND_TEXT,x
                    rts
                else_end

                cmp # CMD_KEY_SEARCH_UP
                if_eq_then
                    sta COMMAND_TEXT,x
                    rts
                else_end

                ;jmp L246C
                bvc L246C
                brk
            else_end

            pla
            cmp # PETSCII_RETURN
            if_eq_then
                ;jmp L249D
                bvc L249D
                brk
            else_end

    L246C:
            cpy # OUR_SCREEN_WIDTH - 1
            if_ne_then
                sta COMMAND_TEXT,x
                jsr L240D                                   ; A+, V378D+
                sta [TFB],y
                inx
                iny
            else_end
        end
    next
        ;jmp _loop
        bvc _loop
        brk
    end
    
    L247D:

    tya
    pha
        ldy # 0
        cpx # 0
        if_ne_then
            lda COMMAND_TEXT
            cmp # PETSCII_LATIN_LETTER_A
            if_cc_then
                ldy # 1
                ;jmp L2497
                bne L2497
                brk
            else_end

            cmp # PETSCII_LATIN_LETTER_Z + 1
            if_cs_then
                ldy # 1
            else_end
        else_end

        L2497:
        sty L24E5
    pla
    tay
    rts

    L249D:
    cpx # 0
    if_ne_then
        from_loop
            dex
            lda COMMAND_TEXT,x
            cmp # PETSCII_QUOTATION_MARK
            beq L24AE
        next
            cmp # PETSCII_SPACE
            beq _loop
        end

        inx
    else_end
    
    L24AE:
    lda # PETSCII_NUL
    sta COMMAND_TEXT,x
    sta NAME_TEXT
    from
        ldx # $FF
    loop
        inx
        lda COMMAND_TEXT,x
        if_eq_then
            rts
        else_end

        cmp # PETSCII_SPACE
        bne _loop
    end

    lda # PETSCII_NUL
    sta COMMAND_TEXT,x
    from_loop
        inx
        lda COMMAND_TEXT,x
        bne L24CF
        rts
        L24CF:

        cmp # PETSCII_QUOTATION_MARK
        beq L24D8
        cmp # PETSCII_SPACE
        beq _loop
    end

    dex
    L24D8:
    from
        ldy # $FF
    loop
        inx
        iny
        lda COMMAND_TEXT,x
        sta NAME_TEXT,y
    next
        bne _loop
    end
    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L24E6
    stx L251F
    jsr L2521
    try
        from_loop
            tya
            pha
            jsr KERNAL_GETIN
            if_ne_then
                cmp # PETSCII_SPACE
                bne _catch
                ldx L251F
                bne _catch
            else_end

            pla
            tay
            lda ZPKERNAL_TIME_2
            sec
            sbc L251E
;>>++
clv
;<<++
            cmp # CURSOR_BLINK_DELAY
            if_pl_then
                jsr L2521
            else_end
        next
            ;jmp _loop
            bvc _loop
            brk
        end
    catch_finally_end

    sta L2520
    pla
    tay
    ldx L251F
    lda # PETSCII_SPACE
    sta [TFB],y
    lda L2520

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2521
    lda [TFB],y
    eor # $80
    sta [TFB],y
    lda ZPKERNAL_TIME_2
    sta L251E

    rts
.endproc

;;; summary: Show X#Y on command/status line 
;;; changed: TFB, TFC
.proc PRINT_STATUS_LINE
    lda # <STATUS_COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFB
    lda # >STATUS_COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFC
    jsr PRINT_FILL_LINE                                     ; A+ X- Y+
    jsr KERNAL_CLRCHN
    from_loop
        jsr L24E6
    next
        cmp # PETSCII_RETURN
        bne _loop
    end

    jsr L2545

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2545
    ; Buffer name
    from
        lda CURRENT_BUFFER_INDEX
        ; A := 8 * A
        asl
        asl
        asl
        tay
        ldx # 0
    loop
        lda BUFFER_TABLE_NAME,y
        beq _end                                            ; break
        sta STATUS_LINE_CONTENT_BUFFER,x
    next
        iny
        inx
        bne _loop
    end

    ; Right fill with spaces
    from
        lda # PETSCII_SPACE
    loop
        sta STATUS_LINE_CONTENT_BUFFER,x
    next
        inx
        cpx # BUFFER_NAME_MAX_LENGTH
        bne _loop
    end

    ; Line
    ldx CURRENT_BUFFER_LINE_LO
    ldy CURRENT_BUFFER_LINE_HI
    inx
    if_eq_then
        iny
    else_end

    jsr INT_TO_STRING
    from
        ldx # LINE_MAX_DIGIT_COUNT - 1
    loop
        lda INT_TO_STRING_RESULT,x
        sta STATUS_LINE_CONTENT_LINE,x
    next
        dex
        bpl _loop
    end

    ; Column
    ldx CURRENT_BUFFER_COLUMN
    inx
    ldy # 0
    jsr INT_TO_STRING
    from
        ldx # COLUMN_MAX_DIGIT_COUNT - 1
    loop
        lda INT_TO_STRING_RESULT,x
        sta STATUS_LINE_CONTENT_COLUMN,x
    next
        dex
        bpl _loop
    end

    ; Mode indicator
    bit G_MODE
    if_pl_then
        ; G_MODE = MODE_EDIT
        lda # STATUS_LINE_CONTENT_MODE_EDIT
        bne _end                                            ; bra
    else
        ; G_MODE = MODE_SELECT
        lda # STATUS_LINE_CONTENT_MODE_SELECT
    end
    ;
    sta STATUS_LINE_CONTENT_MODE

    lda # <STATUS_COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFB
    lda # >STATUS_COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFC
    ; Show/update status line
    ldx # <STATUS_LINE_CONTENT
    ldy # >STATUS_LINE_CONTENT
    jsr PRINT_FILL_LINE                                     ; A+ X- Y+

    rts
.endproc

;;; summary: X#Y (assuming in [0,9999] to string at INT_TO_STRING_RESULT
;;; in:
;;;   X  lo
;;;   Y  hi
;;; out:
;;;   INT_TO_STRING_RESULT
;;; notes:
;;;    If X#Y == 10.000 then you get ":000" etc
;;; changed: A+ X+ Y+ BX+ CX+
.proc INT_TO_STRING
    stx BL
    sty BH
    ; Clear INT_TO_STRING_RESULT
    from
        ldx # INT_TO_STRING_DIGIT_COUNT - 1
        lda # PETSCII_SPACE
    loop
        sta INT_TO_STRING_RESULT,x
    next
        dex
        bpl _loop
    end

    from
        ldx # 0
        ldy # INT_TO_STRING_DIGIT_COUNT - 1
    loop
        from
            lda # 0
            sta CH
        loop
            sec
            lda BL
            sbc TABLE_POWER_OF_10_LO,y
;>>++
;clv
;<<++
            sta CL
            lda BH
            sbc TABLE_POWER_OF_10_HI,y
;>>++
;clv
;<<++
            bcc _end                                        ; break
            sta BH
            lda CL
            sta BL
        next
            inc CH
            bne _loop
        end

        lda CH
        if
            bne _then                                       ; L2604
            cpx # 0
            beq _end                                        ; L260B
            ; X != 0
        then                                                ; L2604:
            ; CH != 0 or X != 0
            clc
            adc # PETSCII_DIGIT_ZERO
;>>++
;clv
;<<++
            sta INT_TO_STRING_RESULT,x
            inx
        else_end                                            ; L260B:
    next
        dey
        bpl _loop
    end
    ; Y = 0

    txa
    if_eq_then
        lda # PETSCII_DIGIT_ZERO
        sta INT_TO_STRING_RESULT
    else_end

;>>++
clv
;<<++

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2627
    jsr L1BCB
    lda V37D4
    sta CURRENT_BUFFER_B
    lda V37D5
    sta CURRENT_BUFFER_C
    jsr L1982
    if_cs_then
        dec V37D6
    else_end

    lda CURRENT_BUFFER_B
    sta V37D4
    lda CURRENT_BUFFER_C
    sta V37D5
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2649
    lda V37D6
    cmp # EDIT_PANEL_LAST_LINE
    if_ne_then
        inc V37D6
        rts
    else_end

    jsr L1BCB
    lda V37D4
    sta CURRENT_BUFFER_B
    lda V37D5
    sta CURRENT_BUFFER_C
    jsr L19DD
    lda CURRENT_BUFFER_B
    sta V37D4
    lda CURRENT_BUFFER_C
    sta V37D5
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2671
    jsr L1BCB
    lda V37D7
    sta CURRENT_BUFFER_B
    lda V37D8
    sta CURRENT_BUFFER_C
    jsr L1982
    lda CURRENT_BUFFER_B
    sta V37D7
    lda CURRENT_BUFFER_C
    sta V37D8
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L268E
    jsr L1BCB
    lda V37D7
    sta CURRENT_BUFFER_B
    lda V37D8
    sta CURRENT_BUFFER_C
    jsr L19DD
    lda CURRENT_BUFFER_B
    sta V37D7
    lda CURRENT_BUFFER_C
    sta V37D8
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L26AB
    tax
    lda L272B
    sta BUFFER_TABLE_HEAD,x
    sta BUFFER_TABLE_B,x
    sta TFC
    lda # 0
    sta TFB
    tay                                                     ; Y = BLOCK_OFFSET_NEXT = 0
    lda [TFB],y
    sta ZP_0E
    tya
    sta [TFB],y
    iny                                                     ; Y = BLOCK_OFFSET_PREVIOUS = 1
    sta [TFB],y
    lda # BLOCK_OFFSET_POINTER_MIN_VALUE
    iny                                                     ; Y = BLOCK_OFFSET_POINTER = 2
    sta [TFB],y
    sta BUFFER_TABLE_C,x
    lda # PETSCII_NUL
    sta BUFFER_TABLE_D,x
    sta BUFFER_TABLE_E,x
    iny                                                     ; Y = 3
    sta [TFB],y

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc L26DA
    tax
    lda BUFFER_TABLE_HEAD,x
    if_eq_then
        rts
    else_end

    sta TFC
    lda # 0
    sta TFB
    sta BUFFER_TABLE_HEAD,x
    tay

    from_loop
        lda [TFB],y
        pha
        lda ZP_0E
        sta [TFB],y
        lda TFC
        sta ZP_0E
        pla
        sta TFC
    next
        bne _loop
    end

    cpx CURRENT_BUFFER_INDEX
    if_eq_then
        jsr L1B77                                           ; May throw EXCEPTION_OUT_OF_MEMORY
        sta L272B
        lda CURRENT_BUFFER_INDEX
        jsr L26AB
        ldx CURRENT_BUFFER_INDEX
        lda BUFFER_TABLE_HEAD,x
        sta CURRENT_BUFFER_HEAD
        lda BUFFER_TABLE_B,x
        sta CURRENT_BUFFER_B
        lda BUFFER_TABLE_C,x
        sta CURRENT_BUFFER_C
        lda BUFFER_TABLE_D,x
        sta CURRENT_BUFFER_LINE_LO
        lda BUFFER_TABLE_E,x
        sta CURRENT_BUFFER_LINE_HI
        lda # 0
        sta T5A
    else_end

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc L272C
    pha
        tax
        lda BUFFER_TABLE_HEAD,x
        if_eq_then
            ; No head block -> allocate
            jsr L1B77                                           ; out if C=0 then A ; May throw EXCEPTION_OUT_OF_MEMORY
            if_cs_then
                ; Allocation failed  if_vs_then ... TODO
                pla
                rts
            else_end

            sta L272B
        else_end

        ldx CURRENT_BUFFER_INDEX
        if_pl_then
            lda CURRENT_BUFFER_HEAD
            sta BUFFER_TABLE_HEAD,x
            lda CURRENT_BUFFER_B
            sta BUFFER_TABLE_B,x
            lda CURRENT_BUFFER_C
            sta BUFFER_TABLE_C,x
            lda CURRENT_BUFFER_LINE_LO
            sta BUFFER_TABLE_D,x
            lda CURRENT_BUFFER_LINE_HI
            sta BUFFER_TABLE_E,x
        else_end
    pla
    sta CURRENT_BUFFER_INDEX
    tax
    lda BUFFER_TABLE_HEAD,x
    if_eq_then
        txa
        pha
            jsr L26AB
        pla
        tax
        lda BUFFER_TABLE_HEAD,x
    else_end

    sta CURRENT_BUFFER_HEAD
    lda BUFFER_TABLE_B,x
    sta CURRENT_BUFFER_B
    lda BUFFER_TABLE_C,x
    sta CURRENT_BUFFER_C
    lda BUFFER_TABLE_D,x
    sta CURRENT_BUFFER_LINE_LO
    lda BUFFER_TABLE_E,x
    sta CURRENT_BUFFER_LINE_HI

    rts
.endproc

;;; summary: Find buffer, optionally creating new if not exists
;;; in:
;;;   A          Boolean flag: create if not exists?
;;;   NAME_TEXT  Buffer name to find
;;; out:
;;;   A    Buffer index if OK
;;;   C=0  OK
;;;   C=1  Error: requested buffer does not exist and do not create if not exists.
;;; throws: EXCEPTION_NO_MORE_FREE_FILES
;;; changed: A+ X+ Y+ TFB+ TFC+ ...
.proc FIND_BUFFER_OPT_CREATE
    sta CREATE_BUFFER_IF_NOT_EXISTS
    from LOOP
        lda # <NAME_TEXT
        sta TFB
        lda # >NAME_TEXT
        sta TFC
        ; PFD#PFE is pointer to current entry in BUFFER_TABLE_NAME
        lda # <BUFFER_TABLE_NAME
        sta PFD
        lda # >BUFFER_TABLE_NAME
        sta PFE
        ldx # 0
    loop
        stx L2807                                           ; Temp can use e.g. AL
        lda # BUFFER_NAME_MAX_LENGTH - 1; zzz
        jsr STRING_COMPARE_SIGNIFICANT
        if_eq_then
            ;bne L27B2
            ; Match
            ldx L2807
            cpx # BUFFER_INDEX_CUSTOM_FIRST
            if
                bcc _then                                   ; X < BUFFER_INDEX_CUSTOM_FIRST -> Special case: do not allocate
                lda BUFFER_TABLE_HEAD,x
                beq _end                                    ; A = BUFFER_TABLE_HEAD[x] = 0 -> Allocate
                ; A = BUFFER_TABLE_HEAD[x] != 0
            then
                ; X < BUFFER_INDEX_CUSTOM_FIRST or A = BUFFER_TABLE_HEAD[x] != 0
                ; Special case: do not allocate: 'main' has got a head, clipboard operations will allocate for paste if needed.
                ; Main or paste block or found buffer with head
                txa                                         ; return A
                clc                                         ; OK
                rts
            else_end

            ; X >= 2 or A = BUFFER_TABLE_HEAD[x] = 0
            ; Found custom (not main, not paste) buffer without head.
            ;jmp LOOP::_end                                  ; break
            bvc LOOP::_end
            brk
        else_end
        ; No match
    next
        ; PFD#PFE := address of next entry in BUFFER_TABLE_NAME
        lda PFD
        clc
        adc # BUFFER_NAME_MAX_LENGTH
;>>++
clv
;<<++
        sta PFD
        if_cs_then
            inc PFE
        else_end

        ldx L2807
        inx
        cpx # BUFFER_TABLE_SIZE
        bne _loop                                           ; X != BUFFER_TABLE_SIZE -> ; X < BUFFER_TABLE_SIZE
    end
    ; X = BUFFER_TABLE_SIZE

    ; Not found or found custom (not main, not paste) buffer without head.
    ; Allocate if option says so.

    lda CREATE_BUFFER_IF_NOT_EXISTS
    if_eq_then
        ; CREATE_BUFFER_IF_NOT_EXISTS = FALSE
        sec                                                 ; Error
        rts
    else_end

    ; CREATE_BUFFER_IF_NOT_EXISTS = TRUE

    ; Find free slot
    from
        ldx # BUFFER_INDEX_CUSTOM_FIRST                     ; Because: 0=Main, 1=Paste always in use.
    loop
        lda BUFFER_TABLE_HEAD,x
        beq _end                                            ; Found empty slot -> break
        ; Slot in use
    next
        inx
        cpx # BUFFER_TABLE_SIZE
        if_eq_then
            ; X = BUFFER_TABLE_SIZE
            ; Exhaused
            lda # EXCEPTION_NO_MORE_FREE_FILES
            sta ZP_EXCEPTION_CODE
            sec
            bit ZP_BIT_V
            rts                                             ; throw
        else_end

        bne _loop                                           ; X != BUFFER_TABLE_SIZE -> X < BUFFER_TABLE_SIZE
    end

    ; Found free slot in `X`
    stx L2807

    ; Copy `NAME_TEXT` to found slot in `BUFFER_TABLE_NAME`.
    from
                .assert BUFFER_NAME_MAX_LENGTH = 8, error, "Require BUFFER_NAME_MAX_LENGTH = 8 else multiplication code below will not be correct."
        ; TFB#TFC := &BUFFER_TABLE_NAME[X * BUFFER_NAME_MAX_LENGTH] Points to start address of `X`-th entry in BUFFER_TABLE_NAME.
        txa
        ; A := 8 * A
        asl
        asl
        asl
        adc # <BUFFER_TABLE_NAME
        sta TFB
        lda # 0
        adc # >BUFFER_TABLE_NAME
;>>++
clv
;<<++
        sta TFC
        ; Copy NAME_TEXT to TFB#TFC.
        ldy # 0
    loop
        lda NAME_TEXT,y
        sta [TFB],y
    next
        beq _end                                            ; nul-terminator has been copied
        iny
        ; check Y <= BUFFER_NAME_MAX_LENGTH
        bne _loop                                           ; bra
    end

    lda L2807
    clc                                                     ; OK

    rts
.endproc

;;; summary: Command: List buffers
;;; changed: ...
.proc CMD_LIST
    lda # PETSCII_CLR
    jsr KERNAL_CHROUT
    jsr L1A89
    ;--lda # PETSCII_BLACK
    ;--jsr KERNAL_CHROUT
 
    ; Show header
    ldx # <RESOURCE_STRING_LIST_HEADER
    ldy # >RESOURCE_STRING_LIST_HEADER
    jsr PUTS
    from
        lda # <BUFFER_TABLE_NAME
        sta T5C
        lda # >BUFFER_TABLE_NAME
        sta T5D
        ldx # 0
    loop
        stx L2807                                           ; local index can use AL e.g.
        cpx CURRENT_BUFFER_INDEX
        if_eq_then
            lda CURRENT_BUFFER_HEAD
            ;jmp _end
            bvc _end
            brk
        else
            lda BUFFER_TABLE_HEAD,x
        end

        if_ne_then
            pha
            ldx T5C
            ldy T5D
            jsr PUTS
            from_loop
                lda # PETSCII_SPACE
                jsr KERNAL_CHROUT
            next
                iny
                cpy # PETSCII_RETURN
                bne _loop
            end

            pla
            jsr L1FFE
            jsr A_TO_DECIMAL_3_A_X_Y
            jsr KERNAL_CHROUT
            txa
            jsr KERNAL_CHROUT
            tya
            jsr KERNAL_CHROUT
            lda # PETSCII_RETURN
            jsr KERNAL_CHROUT
        else_end

        lda T5C
        clc
        adc # BUFFER_NAME_MAX_LENGTH
;>>++
clv
;<<++
        sta T5C
        if_cs_then
            inc T5D
        else_end
    next
        ldx L2807
        inx
        cpx # BUFFER_TABLE_SIZE
        bne _loop
    end

    ; Show footer
    ldx # <RESOURCE_STRING_LIST_FOOTER
    ldy # >RESOURCE_STRING_LIST_FOOTER
    jsr PUTS
    lda ZP_0E
    jsr L1FFE
    jsr A_TO_DECIMAL_3_A_X_Y
    jsr KERNAL_CHROUT
    txa
    jsr KERNAL_CHROUT
    tya
    jsr KERNAL_CHROUT
    ; Show "hit return to continue"
    ldx # <RESOURCE_STRING_HIT_RETURN_TO_CONTINUE
    ldy # >RESOURCE_STRING_HIT_RETURN_TO_CONTINUE
    jsr PRINT_STATUS_LINE
    jsr L1A89

    rts
.endproc

;;; summary: Put string at X#Y
;;; in:
;;;   X  lo address
;;;   Y  hi address
;;; changed: Y+
.proc PUTS                                                  ; L293D
    from
        stx T5E
        sty T5F
        ldy # 0
    loop
        lda [T5E],y
        beq _end                                            ; break
        jsr KERNAL_CHROUT                                   ; A- X- Y-
    next
        iny
        bne _loop
    end

    rts
.endproc

;;; summary: `A` to decimal string representation in `A` (10^2) `X` (10^1) `Y` (10^0)
;;; in: A
;;; out: A X Y
;;; changes: A  X  Y
.proc A_TO_DECIMAL_3_A_X_Y
    from
        ldx # PETSCII_SPACE
        ldy # PETSCII_SPACE
    loop
        sec
        sbc # 100
;>>++
clv
;<<++
        bcc _end
        cpx # PETSCII_SPACE
        if_eq_then
            ldx # PETSCII_DIGIT_ZERO
            ldy # PETSCII_DIGIT_ZERO
        else_end
    next
        inx
        ;jmp _loop
        bvc _loop
        brk
    end

    adc # 100
    from_loop
        sec
        sbc # 10
;>>++
clv
;<<++
        bcc _end                                            ; break
        cpy # PETSCII_SPACE
        if_eq_then
            ldy # PETSCII_DIGIT_ZERO
        else_end
    next
        iny
        ;jmp _loop
        bvc _loop
        brk
    end

    adc # 10 + PETSCII_DIGIT_ZERO
;>>++
clv
;<<++
    sty L297F
    tay
    txa
    ldx L297F

    rts
.endproc

;;; summary: Command: Enter command mode
;;; throws: EXCEPTION
;;; changed: A  X  Y  AL  BX  CX
.proc CMD_COMMAND_MODE
    ; Show "cmd: " on command line
    ldx # <RESOURCE_STRING_COMMAND_PROMPT
    ldy # >RESOURCE_STRING_COMMAND_PROMPT
    jsr GET_COMMAND_TEXT
    lda COMMAND_TEXT
    if_eq_then
        ; No command text -> leave command mode
        jsr L2545
        rts                                                 ; return
    else_end

    ; We've got a command text
    if
        cmp # PETSCII_LATIN_LETTER_A
        bcc _then                                       ; A < 'A' -> then
        ; A >= 'A'
        cmp # PETSCII_LATIN_LETTER_Z + 1
        bcc _else                                       ; A >= 'A' and A <= 'Z' -> else
        ; A >= 'A' and A > 'Z'
    then
        ; Not a command. Maybe search down/up.
        jsr L2D74
       ;jmp _end
       ;bvc _end
        rts                                             ; return
    else
        ; Maybe a command
        ; A >= 'A' and A <= 'Z'
        jsr MAP_COMMAND_NAME_TO_COMMAND_NUMBER      ; out: A | changed: X+ Y+ AL+ BX+ CX+ | throws: EXCEPTION_NO_SUCH_ELEMENT
        if_vs_then
            ; Throw EXCEPTION_COMMAND_NOT_FOUND
            lda # EXCEPTION_COMMAND_NOT_FOUND
            sta ZP_EXCEPTION_CODE
            rts
        else_end

        jsr EXECUTE_COMMAND                         ; in: A | changed: A+ X+ Y+ V=0 DX+ ... | throws: EXCEPTION
       ;bvs _rethrow
       ;if_vs_then
       ;    ; Rethrow
       ;    rts
       ;else_end
    end

    _rethrow:
    rts
.endproc

;;; summary: Map command name to command number
;;; in:
;;;    COMMAND_TEXT  Nul-terminated string
;;; out:
;;;   A  Command number
;;; throws: EXCEPTION_NO_SUCH_ELEMENT
;;; changed: A X Y AL BX CX
.proc MAP_COMMAND_NAME_TO_COMMAND_NUMBER
    from
        lda # <COMMAND_TEXT
        sta CL
        lda # >COMMAND_TEXT
        sta CH
        ldy # 0
    loop
        sty AL                                              ; Map index
        lda MAP_COMMAND_NAME_TO_COMMAND_NUMBER_KEYS_NAME_LO,y
        sta BL
        lda MAP_COMMAND_NAME_TO_COMMAND_NUMBER_KEYS_NAME_HI,y
        sta BH
        ldx MAP_COMMAND_NAME_TO_COMMAND_NUMBER_KEYS_SIGNIFICANT_CHAR_COUNT,y
        jsr STRING_COMPARE_SIGNIFICANT_BX_CX_X              ; A+ X+ Y+
        if_eq_then
            ldx AL
            lda MAP_COMMAND_NAME_TO_COMMAND_NUMBER_VALUES,x
            rts                                             ; return A
        else_end
    next
        ldy AL
        iny
        cpy # MAP_COMMAND_NAME_TO_COMMAND_NUMBER_SIZE
        bne _loop
    end

    ; Throw EXCEPTION_NO_SUCH_ELEMENT
    bit ZP_BIT_V
    lda # EXCEPTION_NO_SUCH_ELEMENT
    sta ZP_EXCEPTION_CODE

    rts
.endproc

;;; summary: Execute command with number in `A`
;;; in:
;;;   A  Command number
;;; throws: EXCEPTION
;;; changed: A+ X+ Y+ V=0 DX+ ...
.proc EXECUTE_COMMAND
    tax
    lda MAP_COMMAND_NUMBER_TO_HANDLER_LO,x
    sta DL
    lda MAP_COMMAND_NUMBER_TO_HANDLER_HI,x
    sta DH
    jsr JSR_INDIRECT_DX                                     ; throws: EXCEPTION
    if_vs_then
        jsr L21A2                                           ; A+ X+ Y+ V=0 ...
        bit ZP_BIT_V
        rts                                                 ; Rethrow
    else_end

    ; check V=0
    jsr L21A2                                               ; V=0
    ; check V=0

    rts
.endproc

;;; summary: Command: Clear current buffer
;;; throws: EXCEPTION_NO_MORE_FREE_FILES ?
.proc CMD_CLEAR
    lda # MODE_EDIT
    sta G_MODE
    lda NAME_TEXT
    if_eq_then
        sta CURRENT_BUFFER_LINE_LO
        sta CURRENT_BUFFER_LINE_HI
        lda CURRENT_BUFFER_INDEX
        ;jmp _end
        bvc _end
        brk
    else
        lda # FALSE                                         ; Do not create buffer if not exists
        jsr FIND_BUFFER_OPT_CREATE                          ; out A, C, V ; May throw EXCEPTION_NO_MORE_FREE_FILES ?
        if_cs_then
            ; Not found
            rts
        else_end
        cmp # BUFFER_INDEX_PASTE
        if_eq_then
            ; May not clear Paste buffer.
            rts
        else_end
    end

    jsr L26DA

    rts
.endproc


;;; summary: Command: Goto buffer
;;; throws: EXCEPTION_NO_MORE_FREE_FILES
;;; changed: ...
.proc CMD_GOTO
    lda NAME_TEXT
    if_eq_then
        rts
    else_end

    lda # TRUE                                              ; Do create buffer if not exists
    jsr FIND_BUFFER_OPT_CREATE                              ; out: A (if C=0) | throws: EXCEPTION_NO_MORE_FREE_FILES
    bvs _rethrow                                            ; Exception -> rethrow
   ;if_vs_then
   ;    ; Exception
   ;    rts                                                 ; Rethrow
   ;else_end

    if_cs_then
        ; Not found?
        rts
    else_end

    cmp CURRENT_BUFFER_INDEX   ; Current/active buffer?
    if_eq_then
        rts
    else_end

    cmp # BUFFER_INDEX_PASTE
    if_eq_then
        ; User may not go to "paste" edit buffer.
        rts
    else_end

    jsr L272C
    lda # MODE_EDIT
    sta G_MODE
    lda # $0C                                                ; ?
    sta T5A
    lda # $27                                                ; ?
    sta CURSOR_SCREEN_X

    _rethrow:
    rts
.endproc

;;; summary: Open disk file
;;; in:
;;;   A          Read/write flag: FALSE: read , TRUE: write
;;;   NAME_TEXT  File name (nul-terminated string)
;;; throws: EXCEPTION_DRIVE_NOT_PRESENT
;;; changed: ...
.proc OPEN_DISK_FILE
    pha
        ; Close disk command channel
        lda # DISK_CMD_FH
        jsr KERNAL_CLOSE
        ; Open disk command channel
        lda # DISK_CMD_FH
        ldx ZPKERNAL_FA                                         ; Last used serial device
        ldy # DISK_CMD_SA
        jsr KERNAL_SETLFS
        lda # 0
        jsr KERNAL_SETNAM                                       ; Disk command has no name
        jsr KERNAL_OPEN
        ; Open disk data
        lda # SERIAL_DATA_FH
        ldx ZPKERNAL_FA
        ldy # SERIAL_DATA_DOC_SA
        jsr KERNAL_SETLFS
        ; Y := NAME_TEXT.INDEX_OF(PETSCII_NUL)
        from
            ldy # 0
        loop
            lda NAME_TEXT,y
            beq _end                                            ; break
        next
            iny
            ;jmp _loop
            bvc _loop
            brk
        end
    pla
    ; Read or write?
    if_ne_then
        ; Write
        ; Make NAME_TEXT ending with ",s,w".
        dey
        dey
        lda NAME_TEXT,y
        iny
        iny
        cmp # PETSCII_COMMA
        if_ne_then
            lda # PETSCII_COMMA
            sta NAME_TEXT,y
            iny
            lda # PETSCII_LATIN_LETTER_S
            sta NAME_TEXT,y
            iny
        else_end

        lda # PETSCII_COMMA
        sta NAME_TEXT,y
        iny
        lda # PETSCII_LATIN_LETTER_W
        sta NAME_TEXT,y
        iny
    else_end

    ; Y = NAME_TEXT.LENGTH

    tya
    ldx # <NAME_TEXT
    ldy # >NAME_TEXT
    jsr KERNAL_SETNAM
    jsr KERNAL_OPEN
    if_cs_then                                              ; Fail
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        lda # DISK_CMD_FH
        jsr KERNAL_CLOSE
        ; throw EXCEPTION_DRIVE_NOT_PRESENT
        ldx # <RESOURCE_STRING_EXCEPTION_DRIVE_NOT_PRESENT
        ldy # >RESOURCE_STRING_EXCEPTION_DRIVE_NOT_PRESENT
        ;--pla                                                 ; ?
        ;--pla                                                 ; ?
        jsr PRINT_STATUS_LINE

        rts
    else_end

    jsr READ_DISK_STATUS

    rts
.endproc

;;; summary: Command: Get (load) file
;;; throws: EXCEPTION_DRIVE_NOT_PRESENT, EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc CMD_GET
    ; Set edit mode
    lda # MODE_EDIT
    sta G_MODE

    ; Have file name?
    lda NAME_TEXT
    if_eq_then
        rts                                                 ; no -> return
    else_end

    ; Have file name

    lda # FALSE                                             ; Flag "read"
    jsr OPEN_DISK_FILE                                      ; May throw EXCEPTION_DRIVE_NOT_PRESENT
    if_cs_then
        ; Error
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        jsr KERNAL_CLRCHN
        jsr L2C3F

        rts
    else_end

    jsr L1BCB
    ldx # SERIAL_DATA_FH
    jsr KERNAL_CHKIN
    try
        from_loop
            jsr KERNAL_CHRIN
            jsr L1AE4                                       ; May throw EXCEPTION_OUT_OF_MEMORY
            if_cs_then
                jsr L1C99                                   ; A- X- Y-
                if_cc_then
                    jsr L1BBC
                    cmp # PETSCII_RETURN
                    if_ne_then
                        jsr L1BF7
                        lda # PETSCII_RETURN
                        jsr L1AE4                           ; May throw EXCEPTION_OUT_OF_MEMORY
                    else_end
                else_end

                jmp _catch
            else_end

            jsr L1B9C
        next
            jsr KERNAL_READST
            and # KERNAL_IO_EOI
            beq _loop
        end
    catch_finally_end

    ; End of input
    lda # SERIAL_DATA_FH
    jsr KERNAL_CLOSE
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    jsr KERNAL_CLRCHN
    jsr L1C99                                               ; A- X- Y-
    if_cc_then
        jsr L1BBC
        cmp # PETSCII_RETURN
        if_ne_then
            jsr L1B9C
            lda # PETSCII_RETURN
            jsr L1AE4                                       ; May throw EXCEPTION_OUT_OF_MEMORY
        else_end
    else_end

    jsr L1BD6
    rts
.endproc

;;; summary: Command: Put (save) file
;;; throws: EXCEPTION_DRIVE_NOT_PRESENT
;;; changed: ...
.proc CMD_PUT
    ; Have file name?
    lda NAME_TEXT
    if_eq_then
        rts                                                 ; no -> return
    else_end

    lda # TRUE                                              ; Flag "write"
    jsr OPEN_DISK_FILE                                      ; May throw EXCEPTION_DRIVE_NOT_PRESENT
    if_cs_then
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        lda # DISK_CMD_FH
        jsr KERNAL_CLOSE
        jsr KERNAL_CLRCHN
        jsr L2C3F

        rts
    else_end

    jsr L1BCB
    lda CURRENT_BUFFER_HEAD
    sta CURRENT_BUFFER_B
    lda # BLOCK_OFFSET_POINTER_MIN_VALUE
    sta CURRENT_BUFFER_C
    ldx # SERIAL_DATA_FH
    jsr KERNAL_CHKOUT
    from_loop
        jsr L1BBC
        bcs _end
        jsr KERNAL_CHROUT
        jsr L1B9C
    next
        ;jmp _loop
        bvc _loop
        brk
    end

    jsr L1BD6
    lda # SERIAL_DATA_FH
    jsr KERNAL_CLOSE
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    jsr KERNAL_CLRCHN

    rts
.endproc

;;; summary: Compare strings with a significant number of characters
;;; changed: A+  X+  Y+
.proc STRING_COMPARE_SIGNIFICANT
    tax
    from
        ldy # 0
    loop
        lda [TFB],y
        cmp [PFD],y
        if_ne_then
            ; (A = [TFB],y) != [PFD],y
            rts
        else_end

        ; A = [TFB],y = [PFD],y
        iny
        ; A may be 0
        cmp # 0
        beq _end                                            ; break
    next
        dex
        bne _loop
    end

    rts
.endproc

;;; summary: Read disk status line to V380B
;;; out:
;;;   C=0  OK
;;;   C=1  Fail
;;; changed: A+ X+ Y+
.proc READ_DISK_STATUS
    ldx # DISK_CMD_FH
    jsr KERNAL_CHKIN
    from
        ldy # 0
    loop
        jsr KERNAL_CHRIN
        cmp # PETSCII_RETURN
        beq _end                                            ; break
        sta V380B,y
    next
        iny
        ;jmp _loop
        bvc _loop
        brk
    end

    lda # PETSCII_NUL
    sta V380B,y
    lda V380B
    ora V380B + 1
    cmp # PETSCII_DIGIT_ZERO
    if_eq_then
        clc                                                 ; OK
        ;jmp _end
        bcc _end
        brk
    else
        sec                                                 ; Fail
    end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2C3F
    ldx # <V380B
    ldy # >V380B
    jsr PRINT_STATUS_LINE

    rts
.endproc

;;; summary: Command: Show disk directory
;;; changed: ...
.proc CMD_DIR
    ; Close disk command channel
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    ; Open disk command channel
    lda # DISK_CMD_FH
    ldx ZPKERNAL_FA
    ldy # DISK_CMD_SA
    jsr KERNAL_SETLFS
    lda # 0
    jsr KERNAL_SETNAM                                       ; Disk command does not have a name
    jsr KERNAL_OPEN
    ; open disk data
    lda # SERIAL_DATA_FH
    ldx ZPKERNAL_FA
    ldy # 0
    jsr KERNAL_SETLFS
    lda # 1                                                 ; Length of directory "$"
    ldx # <RESOURCE_STRING_DIR_NAME
    ldy # >RESOURCE_STRING_DIR_NAME
    jsr KERNAL_SETNAM
    jsr KERNAL_OPEN
    jsr READ_DISK_STATUS
    if_cs_then
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        lda # DISK_CMD_FH
        jsr KERNAL_CLOSE
        jsr L2C3F
        rts
    else_end

    lda # PETSCII_CLR
    jsr KERNAL_CHROUT
    jsr L1A89
    ;--lda # PETSCII_BLACK
    ;--jsr KERNAL_CHROUT
    ldx # SERIAL_DATA_FH
    jsr KERNAL_CHKIN
    jsr KERNAL_CHRIN
    jsr KERNAL_CHRIN

    try
        from_loop
            jsr L2D27
            bcs _end                                        ; break
            jsr L2D27
            bcs _end                                        ; break
            jsr L2D27
            bcs _end                                        ; break
            pha
            jsr L2D27
            tay
            pla
            tax
            jsr INT_TO_STRING
            from
                ldx # 0
            loop
                lda INT_TO_STRING_RESULT,x
                cmp # PETSCII_SPACE
                beq _end                                    ; break
                jsr KERNAL_CHROUT
            next
                inx
                cpx # 3
                bne _loop
            end

            lda # PETSCII_SPACE
            jsr KERNAL_CHROUT

            from_loop
                jsr L2D27
                bcs _catch                                  ; throw
                cmp # 0
                beq _end                                    ; break
                jsr KERNAL_CHROUT
            next
                ;jmp _loop
                bvc _loop
                brk
            end

            lda # PETSCII_RETURN
            jsr KERNAL_CHROUT
            from_loop
                lda ZPKERNAL_SFDX                           ; Matrix code of key currently being pressed. Values: $00-$3F: Keyboard matrix code. $40: No key is currently pressed.
                eor # $40
                ora KVAR_SHFLAG                             ; Shift key indicator. Bits: Bit #0: 1 = One or more of left Shift, right Shift or Shift Lock is currently being pressed or locked. Bit #1: 1 = Commodore is currently being pressed. Bit #2: 1 = Control is currently being pressed.
            next
                bne _loop
            end
        next
            jmp _loop
        end
    catch_finally_end

    lda #PETSCII_RETURN
    jsr KERNAL_CHROUT
    jsr KERNAL_CLRCHN
    lda # SERIAL_DATA_FH
    jsr KERNAL_CLOSE
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    ; Clear keyboard buffer
    lda # 0
    sta ZPKERNAL_NDX                                        ; Length of keyboard buffer. Values: $00, 0: Buffer is empty. $01-$0A, 1-10: Buffer length.
    jsr L1A7F
    ; Show "hit return to continue"
    ldx # <RESOURCE_STRING_HIT_RETURN_TO_CONTINUE
    ldy # >RESOURCE_STRING_HIT_RETURN_TO_CONTINUE
    jsr PRINT_STATUS_LINE
    jsr L1A89

    rts
.endproc

;;; summary: read byte from IN
;;; out:
;;;   C=0  OK
;;;   C=1  FAIL
;;;   A    Byte that has been read, if C=0
.proc L2D27
    jsr KERNAL_READST
    cmp # 0
    if_ne_then
        sec                                                 ; Fail
        rts
    else_end

    jsr KERNAL_CHRIN
    clc                                                     ; OK

    rts
.endproc

;;; summary: Send disk command
;;; changed: ...
.proc CMD_DISK
    lda # DISK_CMD_FH
    ldx ZPKERNAL_FA
    ldy # DISK_CMD_SA
    jsr KERNAL_SETLFS
    lda # 0                                                 ; Disk command has no name
    jsr KERNAL_SETNAM
    jsr KERNAL_OPEN
    lda NAME_TEXT
    if_ne_then
        ldx # DISK_CMD_FH
        jsr KERNAL_CHKOUT
        from
            ldx # 0
        loop
            lda NAME_TEXT,x
            beq _end                                        ; break
            jsr KERNAL_CHROUT
        next
            inx
            bne _loop
        end

        jsr KERNAL_CLRCHN
    else_end

    jsr READ_DISK_STATUS
    php
    jsr KERNAL_CLRCHN
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    plp
    if_cs_then
        jsr L2C3F                                           ; Fail
        rts
    else_end

    ; C=0                                                   ; OK

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2D74
    from
        lda # 0
        sta V38AF
        sta V38AD
        ldy # 1
        ldx # 0
    loop
        lda COMMAND_TEXT,y
        cmp # CMD_KEY_SEARCH_DOWN
        if_eq_then
            stx V38AB
            jsr CMD_SEARCH_DOWN
            rts
        else_end

        cmp # CMD_KEY_SEARCH_UP
        if_eq_then
            stx V38AB
            jsr CMD_SEARCH_UP
            rts
        else_end
    next
        cmp COMMAND_TEXT
        beq _end
        sta V386F,x
        iny
        inx
        bne _loop
    end

    from
        inc V38AF
        stx V38AB
        iny
        ldx # 0
    loop
        lda COMMAND_TEXT,y
        cmp # CMD_KEY_SEARCH_DOWN
        if_eq_then
            stx V38AC
            jsr CMD_SEARCH_DOWN
            rts
        else_end

        cmp # CMD_KEY_SEARCH_UP
        if_eq_then
            stx V38AC
            jsr CMD_SEARCH_UP
            rts
        else_end

        cmp COMMAND_TEXT
        beq _end                                            ; break
        sta V388D,x
    next
        iny
        inx
        bne _loop
    end

    from
        inc V38AD
        stx V38AC
    loop
        iny
        lda COMMAND_TEXT,y
        cmp # CMD_KEY_SEARCH_DOWN
        if_eq_then
            jsr CMD_SEARCH_DOWN
            rts
        else_end

        cmp # CMD_KEY_SEARCH_UP
        if_eq_then
            jsr CMD_SEARCH_UP
            rts
        else_end
    next
        bne _loop
    end
.endproc

;;; summary: Command: Search downward
;;; throws: EXCEPTION_SEARCH_STRING_NOT_FOUND
;;; changed: ...
.proc CMD_SEARCH_DOWN
    ldx # <DO_SEARCH_DOWN
    ldy # >DO_SEARCH_DOWN
    jsr DO_SEARCH

    rts
.endproc

;;; summary: Command: Search upward
;;; throws: EXCEPTION_SEARCH_STRING_NOT_FOUND
;;; changed: ...
.proc CMD_SEARCH_UP
    ldx # <DO_SEARCH_UP
    ldy # >DO_SEARCH_UP
    jsr DO_SEARCH

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_SEARCH_STRING_NOT_FOUND
;;; changed: ...
.proc DO_SEARCH
    stx DL
    sty DH

    lda V38AB
    if_eq_then
        rts
    else_end

    from
        lda # 0
        sta V38AE
    loop
        jsr JSR_INDIRECT_DX
        bcc _end                                            ; break
        lda # 1
        sta V38AE
        lda V38AF
        beq _end                                            ; break
        bit G_MODE
        bmi _end                                            ; G_MODE = MODE_SELECT -> break
        ; G_MODE = MODE_EDIT
        jsr L2E4D
        bcs _end                                            ; break
    next
        lda V38AD
        bne _loop
    end

    lda V38AE
    if_eq_then
        jsr L2F91                                           ; May throw EXCEPTION_SEARCH_STRING_NOT_FOUND
        rts
    else_end

    lda V38AF
    if_ne_then
        bit G_MODE
        if_pl_then
            ; G_MODE = MODE_EDIT
            ldx V38AC
            if_ne_then
                from_loop
                    dex
                    beq _end
                    jsr L1C99                               ; A- X- Y-
                next
                    ;jmp _loop
                    bvc _loop
                    brk
                end
            else_end
        else_end
    else_end

    lda # $0C                                                ; ?
    sta T5A
    lda # $23                                                ; ?
    sta CURSOR_SCREEN_X
    jsr L21A2

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc L2E4D
    from
        ldx V38AB
    loop
        jsr L1BF7
    next
        dex
        bne _loop
    end

    lda V38AC
    if_ne_then
        from
            ldx # 0
        loop
            lda V388D,x
            jsr L1AE4                                       ; May throw EXCEPTION_OUT_OF_MEMORY
            if_cs_then
                rts
            else_end

            jsr L1B9C
        next
            inx
            cpx V38AC
            bne _loop
        end

        jsr L1C99                                           ; A- X- Y-
    else_end

    clc

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc DO_SEARCH_DOWN
    lda L1CE7
    pha
    lda L1CE8
    pha
    lda CURRENT_BUFFER_LINE_LO
    pha
    lda CURRENT_BUFFER_LINE_HI
    pha

    try
        from
            jsr L1BCB
            ldy # 0
        loop
            jsr L1BBC
            cmp # PETSCII_RETURN
            if_eq_then
                bit G_MODE
                if_mi_then
                    ; G_MODE = MODE_SELECT
                    inc L1CE7
                    if_eq_then
                        inc L1CE8
                    else_end
                else_end

                inc CURRENT_BUFFER_LINE_LO
                if_eq_then
                    inc CURRENT_BUFFER_LINE_HI
                else_end
            else_end

            jsr L1B9C
            cpy V38AB
            if_eq_then
                pla
                pla
                pla
                pla
                jsr L2EDD
                sec
                rts
            else_end

            jsr L1BBC
            bcs _catch
            cmp V386F,y
            if_eq_then
                iny
                ;jmp _end
                bvc _end
                brk
            else
                cpy # 0
                if_ne_then
                    jsr L2EDD
                else_end
            end
        next
            ;jmp _loop
            bvc _loop
            brk
        end
    catch_finally_end

    pla
    sta CURRENT_BUFFER_LINE_HI
    pla
    sta CURRENT_BUFFER_LINE_LO
    pla
    sta L1CE8
    pla
    sta L1CE7
    jsr L1BD6
    clc

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2EDD
    from_loop
        jsr L1C99                                           ; A- X- Y-
        jsr L1BBC
        cmp # PETSCII_RETURN
        if_eq_then
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                lda L1CE7
                if_eq_then
                    dec L1CE8
                else_end

                dec L1CE7
            else_end

            lda CURRENT_BUFFER_LINE_LO
            if_eq_then
                dec CURRENT_BUFFER_LINE_HI
            else_end

            dec CURRENT_BUFFER_LINE_LO
        else_end
    next
        dey
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc DO_SEARCH_UP
    ldy V38AB
    dey
    jsr L1BCB
    lda L1CE7
    pha
    lda L1CE8
    pha
    lda CURRENT_BUFFER_LINE_LO
    pha
    lda CURRENT_BUFFER_LINE_HI
    pha

    try
        from_loop
            jsr L1C99                                       ; A- X- Y-
            bcs _catch
            jsr L1BBC
            cmp # PETSCII_RETURN
            if_eq_then
                bit G_MODE
                if_mi_then
                    ; G_MODE = MODE_SELECT
                    lda L1CE7
                    if_eq_then
                        dec L1CE8
                    else_end

                    dec L1CE7
                else_end

                lda CURRENT_BUFFER_LINE_LO
                if_eq_then
                    dec CURRENT_BUFFER_LINE_HI
                else_end

                dec CURRENT_BUFFER_LINE_LO
            else_end

            cmp V386F,y
            if_eq_then
                dey
                if_mi_then
                    pla
                    pla
                    pla
                    pla
                    sec
                    rts
                else_end

                ;jmp _end
                bvc _end
                brk
            else
                iny
                cpy V38AB
                if_ne_then
                    jsr L2F6D
                else_end

                dey
            end
        next
            ;jmp _loop
            bvc _loop
            brk
        end
    catch_finally_end

    pla
    sta CURRENT_BUFFER_LINE_HI
    pla
    sta CURRENT_BUFFER_LINE_LO
    pla
    sta L1CE8
    pla
    sta L1CE7
    jsr L1BD6
    clc

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2F6D
    from_loop
        jsr L1BBC
        cmp # PETSCII_RETURN
        if_eq_then
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                inc L1CE7
                if_eq_then
                    inc L1CE8
                else_end
            else_end

            inc CURRENT_BUFFER_LINE_LO
            if_eq_then
                inc CURRENT_BUFFER_LINE_HI
            else_end
        else_end

        jsr L1B9C
    next
        iny
        cpy V38AB
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_SEARCH_STRING_NOT_FOUND
;;; changed: ...
.proc L2F91
    ldx # <RESOURCE_STRING_EXCEPTION_SEARCH_STRING_NOT_FOUND
    ldy # >RESOURCE_STRING_EXCEPTION_SEARCH_STRING_NOT_FOUND
    jsr PRINT_STATUS_LINE

    rts
.endproc

;;; summary: Initialize
;;; changed: A, X, Y, ...
.proc INITIALIZE

    ; For setting `V`.
    lda # CPU_P_V
    sta ZP_BIT_V

    ; Setup `brk` handler, saved handler is used in `CMD_QUIT`.
    lda KERNAL_CBINV
    sta OLD_KERNAL_CBINV
    lda KERNAL_CBINV + 1
    sta OLD_KERNAL_CBINV + 1
    lda # <CMD_PANIC
    sta KERNAL_CBINV
    lda # >CMD_PANIC
    sta KERNAL_CBINV + 1

    ; Clear any exception
    clv

    ; Set all keys repeat
    lda # $80                                               ; All keys repeat
    sta KVAR_RPTFLG                                         ; Keyboard repeat switch. Bits: Bits #6-#7: %00 = Only cursor up/down, cursor left/right, Insert/Delete and Space repeat; %01 = No key repeats; %1x = All keys repeat.
    ; A = $80 , X = ? Y = ?
    ;
    ldy # 0
    sty ZP_EXCEPTION_CODE                                   ; EXCEPTION_NONE
    sty G_MODE                                              ; MODE_EDIT
    sty T22
    sty T26
    sty CURRENT_BUFFER_LINE_LO
    sty CURRENT_BUFFER_LINE_HI
    sty T4E                                                 ; T4E = 0
    sty T5A
    sty CURSOR_SCREEN_X
    sty L1CE9
    sty L1CEA
    sty V38AB

    ; Initialize edit buffers: First byte of page points to page of next block.
    sei
        lda # CPU_PORT_DATA_BASIC_RAM_IO_RAM_KERNAL_RAM_DATASETTE_DEFAULT
        sta CPU_PORT_DATA
        ; A = ? , X = ? Y = $00
            from
                lda # EDIT_BUFFERS_1_FIRST_PAGE
                ; A = EDIT_BUFFERS_1_FIRST_PAGE , X = ? Y = $00
                sta ZP_0E
                ; [ZP_0E] = EDIT_BUFFERS_1_FIRST_PAGE
            loop
                sta CURRENT_BUFFER_B
                clc
                adc # 1
;>>++
clv
;<<++
                cmp # EDIT_BUFFERS_1_LAST_PAGE + 1
                if_eq_then
                    ; A = EDIT_BUFFERS_1_LAST_PAGE + 1
                    lda # EDIT_BUFFERS_2_FIRST_PAGE
                    ; A = EDIT_BUFFERS_2_FIRST_PAGE
                else_end
                sta [T4E],y
            next
                cmp # EDIT_BUFFERS_2_LAST_PAGE
                bne _loop
            end
            ; A = EDIT_BUFFERS_2_LAST_PAGE , X = ? , Y = 0

        lda # CPU_PORT_DATA_BASIC_RAM_IO_AREA_KERNAL_ROM_DATASETTE_DEFAULT
        sta CPU_PORT_DATA
    cli

    ; Now BASIC is RAM, IO is devices, Kernal is ROM

    ; A = ? , X = ? , Y = 0
    ; T4E = $00
    ; CURRENT_BUFFER_B = EDIT_BUFFERS_2_LAST_PAGE
    ; Set last page in edit buffer 2 next page pointer to 0
    ;sty VBF00
    tya
    ; A = 0 , X = ? , Y = 0
    sta [T4E],y
    ; [EDIT_BUFFERS_2_LAST_PAGE#0] = 0

    ; Initialize BUFFER_TABLE_HEAD entries to 0. BUFFER_TABLE_HEAD[] := [ 0, ..., 0 ]
    from
        ;lda # 0
        ldx # BUFFER_TABLE_SIZE - 1
    loop
        sta BUFFER_TABLE_HEAD,x
    next
        dex
        bpl _loop
    end
    ; A = $00 , X = $FF , Y = $00
    ;
    stx CURRENT_BUFFER_INDEX                                ; CURRENT_BUFFER_INDEX = $FF
    jsr L272C
    jsr L1A89
    jsr L21A2
    ;
    .if ::FEATURE_ARG = 1
        ; Process arguments, if any: load file.
        lda SHELL_ARGC
        cmp # 2
        if_eq_then
            ; argc == 2, i.e. argv = [ "ED" , "FILE" ]
            ; T5C#T5D := SHELL_ARGV[1]
            clc
            lda SHELL_ARGV_LO
            adc # SIZEOF_ADDR                               ; get argv[1] 
            sta T5C
            lda SHELL_ARGV_HI
            adc # 0
;>>++
clv
;<<++
            sta T5D
            ; T5C#T5D := *argv[1]
            ldy # 0                                         ; Y = 0
            lda [T5C],y
            tax
            iny                                             ; Y = 1
            lda [T5C],y
            sta T5D
            stx T5C
            dey                                             ; Y = 0
            from_loop
                lda [T5C],y
                sta NAME_TEXT,y
            next
                iny
                cmp # 0
                bne _loop
            end

            ; Load
            lda # FALSE                                     ; Flag "Read"
            jsr CMD_GET

            jsr L21A2
        else_end
    .endif

    rts
.endproc

;;; summary: Command: Quit
;;; changed: ...
.proc CMD_QUIT
    ; Jump to BASIC, basically same as <RUN STOP>+<RESTORE>. Selects BASIC ROM, IO devices, Kernal ROM.
    jmp [OLD_KERNAL_CBINV]
        ; Does not return to here.
.endproc

;;; summary: ?
;;; changed: A+ X+ Y+
.proc SCROLL_RIGHT
    from
        lda # <OUR_VIDEO_MATRIX_BASE
        sta TFB
        lda # >OUR_VIDEO_MATRIX_BASE
        sta TFC

        lda P36
        clc
        adc # OUR_SCREEN_WIDTH - 1
;>>++
clv
;<<++
        sta ZAB

        lda # 0
        sta Z9E
        sta T5C

        lda V37D7
        sta Z9F
        sta T5D

        ; [Z9E=$00,Z9F] = [L322E=$00,L322F] = [L3223=$00,L3224]

        ldy # BLOCK_OFFSET_POINTER
        lda [T5C],y
        sta V38B1
        jsr L333B                                           ; A+ L3380+ L337F+

        lda # EDIT_PANEL_FIRST_LINE
        sta PFD                                             ; Screen line index

        ldx V37D8
        stx ZA8                                             ; X = [ZA8]
    loop
        ldy ZA8
        lda [Z9E],y
        if_eq_then
            rts
        else_end

        from
            ldy # 0
            sty ZA9                                         ; Y = [ZA9]
            sty ZAA                                         ; [L3235] = [ZAA]
        loop
            ldy ZA8
            lda [Z9E],y
            cmp # PETSCII_RETURN
            if_eq_then
                lda ZAA
                if_eq_then
                    lda # PETSCII_SPACE
                    pha
                else_end
                
                ;jmp _end
                bvc _end
                brk
            else
                ldy ZA9
                cpy ZAB
                if_eq_then
                    jsr L240D                               ; A+, V378D+
                    pha
                    inc ZAA
                else_end

                cpx V38B1
                if_eq_then
                    jsr L3287                               ; A+ X=2 Y-
                    stx ZA8
                else_end
            next
                inx
                inc ZA8
                iny
                inc ZA9
                ;jmp _loop
                bvc _loop
                brk
            end
        end

        cpx V38B1
        if_eq_then
            jsr L3287                                       ; A+ X=2 Y-
            stx ZA8
        else_end

        from
            inx
            inc ZA8
            ldy # 1
        loop
            lda [TFB],y
            dey
            sta [TFB],y
        next
            iny
            iny
            cpy # OUR_SCREEN_WIDTH
            bne _loop
        end

        pla
        jsr L3381                                           ; A- X- Y-
        dey
        sta [TFB],y
        lda TFB
        clc
        adc # OUR_SCREEN_WIDTH
;>>++
clv
;<<++
        sta TFB
        if_cs_then
            inc TFC
        else_end
    next
        inc PFD
        lda PFD
        cmp # EDIT_PANEL_LAST_LINE + 1
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: A+ X=2 Y-
.proc L3287
    tya
    pha
        ldy # BLOCK_OFFSET_NEXT
        lda [T5C],y
        sta Z9F
        sta ZB1
        sta T5D
        ldy # BLOCK_OFFSET_POINTER
        lda [T5C],y
        sta V38B1
        ldx # 2
    pla
    tay

    rts
.endproc

;;; summary: Scroll to the left
;;; changed: A+ X+ Y+
.proc SCROLL_LEFT
    from OUTER_LOOP
        lda # <OUR_VIDEO_MATRIX_BASE
        sta TFB
        lda # >OUR_VIDEO_MATRIX_BASE
        sta TFC

        lda # 0
        sta ZB0
        sta T5C
        lda V37D7
        sta ZB1
        sta T5D
        ldy # BLOCK_OFFSET_POINTER
        lda [T5C],y
        sta V38B1
        jsr L333B                                           ; A+ L3380+ L337F+
        lda # 0
        sta PFD
        ldx V37D8
        stx Z9C
    loop
        ldy Z9C
        lda [ZB0],y

        if_eq_then
            rts
        else_end

        from INNER_LOOP
            ldy # 0
            sty ZB2
            sty ZB3
        loop
            ldy Z9C
            lda [ZB0],y
            cmp # PETSCII_RETURN
            if_eq_then
                lda ZB2
                if_eq_then
                    lda # PETSCII_SPACE
                    pha
                else_end

                ;jmp INNER_LOOP::_end                        ; break
                bvc INNER_LOOP::_end                        ; break
                brk
            else_end

            ldy ZB3
            cpy P36
            if_eq_then
                jsr L240D                                   ; A+, V378D+
                pha
                inc ZB2
            else_end

            cpx V38B1
            if_eq_then
                jsr L3287                                   ; A+ X=2 Y-
                stx Z9C
            else_end
        next
            inx
            inc Z9C
            iny
            inc ZB3
            ;jmp _loop
            bvc _loop
            brk
        end
    
        ldx Z9C
        cpx V38B1
        if_eq_then
            jsr L3287                                       ; A+ X=2 Y-
            stx Z9C
        else_end

        inx
        inc Z9C
        from
            ldy # OUR_SCREEN_WIDTH
        loop
            dey
            dey
            bmi _end                                        ; break
            lda [TFB],y
            iny
            sta [TFB],y
        next
            ;jmp _loop
            bvc _loop
            brk
        end

        pla
        jsr L3381                                           ; A- X- Y-
        iny
        sta [TFB],y
        lda TFB
        clc
        adc # OUR_SCREEN_WIDTH
;>>++
clv
;<<++
        sta TFB
        if_cs_then
            inc TFC
        else_end
    next
        inc PFD
        lda PFD
        cmp # EDIT_PANEL_LAST_LINE + 1
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: A+ L3380+ L337F+
.proc L333B
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda L1CE8
        if_pl_then
            lda T5A
            sta L3380
            sec
            sbc L1CE7
;>>++
;clv
;<<++
            sta L337F
            lda # 0
            sbc L1CE8
;>>++
clv
;<<++
            if_mi_then
                lda # 0
                sta L337F
            else_end

            ;jmp _end
            bvc _end
            brk
        else
            lda T5A
            sta L337F
            inc L337F
            sec
            sbc L1CE7
;>>++
clv
;<<++
            sta L3380
            inc L3380
            lda # $FF
            sbc L1CE8
;>>++
clv
;<<++
            if_pl_then
                lda # $19                                   ; ?
                sta L3380
            else_end
        end
    else_end

    rts
.endproc

;;; summary: ?
;;; changed: A- X- Y-
.proc L3381
    pha
        bit G_MODE
        if_mi_then
            ; G_MODE = MODE_SELECT
            lda PFD
            cmp L337F
            if_cs_then
                cmp L3380
                if_cc_then
                    pla
                    eor # $80                               ; Reverse?
                    pha
                else_end
            else_end
        else_end
    pla

    rts
.endproc

;;; summary: Process control or printable character
;;; in:
;;;   A: Character to process (!= 0)
;;; throws: EXCEPTION_*
;;; changed: A+ X+ Y+ DX+ ...
.proc PROCESS_CHAR
    ; $00 - $1F Control characters
    ; $20 - $7F Printable characters
    ; $80 - $9F Control characters
    ; $A0 - $FF Printable characters
    cmp # PETSCII_CONTROL_CHARACTERS_2_FIRST
    if_lt_then
        ; A < $80
        cmp # PETSCII_CONTROL_CHARACTERS_1_AFTER
        if_lt_then
            ; A < $20
            jsr PROCESS_CONTROL_CHAR                        ; in: A | throws: EXCEPTION_OUT_OF_MEMORY
            bvs _rethrow                                    ; Exception -> rethrow
            bvc _end                                        ; bra
        else
            ; $20 <= A < 80
            jsr ADD_CHAR                                    ; in: A | throws: EXCEPTION_OUT_OF_MEMORY
            bvs _rethrow                                    ; Exception -> rethrow
        end

        bvc _end                                            ; bra
    else
        ; A >= $80
        cmp # PETSCII_CONTROL_CHARACTERS_2_AFTER
        if_lt_then
            ; $80 <= A < $A0
            jsr PROCESS_CONTROL_CHAR                        ; in: A | throws: EXCEPTION_* (not EXCEPTION_NO_SUCH_ELEMENT)
            bvs _rethrow                                    ; Exception -> rethrow
            bvc _end                                        ; bra
        else
            ; $A0 <= A <= $FF
            jsr ADD_CHAR                                    ; in: A | throws: EXCEPTION_OUT_OF_MEMORY
           ;bvs _rethrow                                    ; Exception -> rethrow
           ;bvc _end                                        ; bra
        end
    end

    _rethrow:
    rts
.endproc

;;; summary: Process control character
;;; in:
;;;   A: character to process (A >= $01 and A <= $1D) or (A >= $80 and A <= $9F)
;;; throws: EXCEPTION_* (except EXCEPTION_NO_SUCH_ELEMENT)
;;; changed:
;;;    A+ X+ Y+ DX+ ...
.proc PROCESS_CONTROL_CHAR
    ; Map keyboard char (key) in A to command number in X
    jsr MAP_KEYBOARD_CHAR_TO_COMMAND_NUMBER                 ; in: A | out: X | throws: EXCEPTION_NO_SUCH_ELEMENT
    if_vs_then
        ; Not in map -> do nothing
        clv                                                 ; Clear exception
        rts
    else_end

    ; We have got a command number in X. Lookup handler and call it.
    ldy MAP_COMMAND_NUMBER_TO_HANDLER_LO,x
    sty DL
    ldy MAP_COMMAND_NUMBER_TO_HANDLER_HI,x
    sty DH
    jsr JSR_INDIRECT_DX                                     ; throws: EXCEPTION_*

    rts
.endproc

;;; summary: Map keyboard key to command number
;;; in:
;;;   A  Keyboard char
;;; out:
;;;   X  Command number
;;; throws: EXCEPTION_NO_SUCH_ELEMENT
;;; changed: A- X+ Y+
.proc MAP_KEYBOARD_CHAR_TO_COMMAND_NUMBER
    from
        ldy # 0
    loop
        cmp MAP_KEYBOARD_CHAR_TO_COMMAND_NUMBER_KEYS,y
        if_eq_then
            ldx MAP_KEYBOARD_CHAR_TO_COMMAND_NUMBER_VALUES,y
            rts
        else_end
    next
        iny
        cpy # MAP_KEYBOARD_CHAR_TO_COMMAND_NUMBER_SIZE
        bne _loop
    end

    ; Throw EXCEPTION_NO_SUCH_ELEMENT
    bit ZP_BIT_V
    lda # EXCEPTION_NO_SUCH_ELEMENT
    sta ZP_EXCEPTION_CODE

    rts
.endproc

;;; summary: Command: Cursor right
;;; changed: ...
.proc CMD_CURSOR_RIGHT
    lda CURRENT_BUFFER_COLUMN
    cmp Z92
    if_ne_then
        ldx CURRENT_BUFFER_COLUMN
        inx
        stx CURRENT_BUFFER_COLUMN
        stx P19
        jsr L1B9C
        lda CURSOR_SCREEN_X
        cmp # BUMP_RIGHT
        if_cs_then
            inc P36
            jsr SCROLL_RIGHT
            jsr L2545
            rts
        else_end

        inc CURSOR_SCREEN_X
        jsr L2545
    else_end

    rts
.endproc

;;; summary Command: Cursor left
;;; changed: ...
.proc CMD_CURSOR_LEFT
    ldx CURRENT_BUFFER_COLUMN
    cpx P36
    if_cc_then
        stx P19
        dec P36
        jsr SCROLL_LEFT
        rts
    else_end

    cpx # EDIT_PANEL_MIN_COLUMN
    if_ne_then
        dex
        stx CURRENT_BUFFER_COLUMN
        stx P19
        jsr L1C99                                           ; A- X- Y-
        lda CURSOR_SCREEN_X
        cmp # BUMP_LEFT
        if_cc_then
            jsr L19D0
            inx
            cpx CURSOR_SCREEN_X
            if_ne_then
                dec P36
                jsr SCROLL_LEFT
                jsr L2545
                rts
            else_end
        else_end

        dec CURSOR_SCREEN_X
        jsr L2545
    else_end

    rts
.endproc

;;; summary: Command: Cursor up
;;; changed: ...
.proc CMD_CURSOR_UP
    lda T5A
    cmp # BUMP_TOP
    if_cs_then
        jsr MOVE_CURSOR_UP                                  ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
        ;jmp _end
        bvc _end                                            ; bra
        brk
    else
        jsr L268E
        if_cs_then
            lda T5A
            if_eq_then
                rts
            else_end

            jsr MOVE_CURSOR_UP                              ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
            ;jmp _end
            bvc _end
            brk
        else
            jsr L2649
            jsr L23DF
            jsr L351B
        end
    end

    jsr L1BEC
    jsr L19DD
    jsr L1BE1
    ldx P19
    jsr L1A2A
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda L1CE7
        if_eq_then
            dec L1CE8
        else_end

        dec L1CE7
        lda ZPKERNAL_PNT_HI
        sta TFC
        lda L1CE8
        if_pl_then
            lda ZPKERNAL_PNT_LO
            sta TFB
            ;jmp _end
            bvc _end
            brk
        else
            lda ZPKERNAL_PNT_LO
            clc
            adc # OUR_SCREEN_WIDTH
    ;>>++
    clv
    ;<<++
            sta TFB
            if_cs_then
                inc TFC
            else_end
        end

        jsr L34F3
    else_end

    lda CURRENT_BUFFER_LINE_LO
    if_eq_then
        dec CURRENT_BUFFER_LINE_HI
    else_end
 
    dec CURRENT_BUFFER_LINE_LO
    jsr L2545

    rts
.endproc

;;; summary: Reverse line @TFB
;;; changed: ...
.proc L34F3
    ldy # OUR_SCREEN_WIDTH - 1
    from_loop
        lda [TFB],y
        eor # $80
        sta [TFB],y
    next
        dey
        bpl _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L34FF
    ldy # 0
    from_loop
        cpy T5A
        beq _end                                            ; break
        jsr L19DD
        bcs _end                                            ; break
    next
        iny
        ;jmp _loop
        bvc _loop
    end

    sty T5A
    lda CURRENT_BUFFER_B
    sta V37D7
    lda CURRENT_BUFFER_C
    sta V37D8

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L351B
    lda # <OUR_VIDEO_MATRIX_BASE
    sta TFB
    lda # >OUR_VIDEO_MATRIX_BASE
    sta TFC
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda L1CE8
        if_pl_then
            lda T5A
            sec
            sbc L1CE7
    ;>>++
    ;clv
    ;<<++
            lda # 0
            sbc L1CE8
    ;>>++
    clv
    ;<<++
            if_mi_then
                lda # $80                                   ; ?
                sta L2340
            else_end
        else_end
    else_end

    ldx V37D7
    ldy V37D8
    jsr L2290
    jsr L22B8

    rts
.endproc

;;; summary: Command: Cursor down
;;; changed: ...
.proc CMD_CURSOR_DOWN
    jsr L1BBC
    if_cs_then
        rts
    else_end

    lda T5A
    cmp # BUMP_BOTTOM
    if_cc_then
        jsr MOVE_CURSOR_DOWN                                ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
        ;jmp _end
        bvc _end
        brk
    else
        jsr L23B1
        jsr L2671
        jsr L2627
        if_cc_then
            jsr L199D
            ;jmp _end
            bvc _end
            brk
        else
            jsr CLEAR_EDIT_PANEL_LAST_LINE
        end
    end

    jsr L1982
    jsr L1BE1
    ldx P19
    jsr L1A2A
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda ZPKERNAL_PNT_HI
        sta TFC
        lda L1CE8
        if_pl_then
            lda ZPKERNAL_PNT_LO
            sec
            sbc # OUR_SCREEN_WIDTH
    ;>>++
    clv
    ;<<++
            sta TFB
            if_cc_then
                dec TFC
            else_end

            ;jmp _end
            bvc _end
            brk
        else
            lda ZPKERNAL_PNT_LO
            sta TFB
        end

        jsr L34F3
        inc L1CE7
        if_eq_then
            inc L1CE8
        else_end
    else_end

    inc CURRENT_BUFFER_LINE_LO
    if_eq_then
        inc CURRENT_BUFFER_LINE_HI
    else_end

    jsr L2545

    rts
.endproc

;;; summary: Command: Page down
;;; changed: ...
.proc CMD_PAGE_DOWN
    lda # PAGE_LINE_COUNT
    sta V38B3
    from_loop
        jsr L1982
        if_cc_then
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                inc L1CE7
                if_eq_then
                    inc L1CE8
                else_end
            else_end

            inc CURRENT_BUFFER_LINE_LO
            if_eq_then
                inc CURRENT_BUFFER_LINE_HI
            else_end
        else_end
    next
        dec V38B3
        bne _loop
    end

    lda # BUMP_BOTTOM
    sta T5A
    jsr L21A2

    rts
.endproc

;;; summary: Command: Page up
;;; changed: ...
.proc CMD_PAGE_UP
    lda # PAGE_LINE_COUNT
    sta V38B3
    jsr L1BEC
    from_loop
        jsr L19DD
        if_cc_then
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                lda L1CE7
                if_eq_then
                    dec L1CE8
                else_end
                dec L1CE7
            else_end
            
            lda CURRENT_BUFFER_LINE_LO
            if_eq_then
                dec CURRENT_BUFFER_LINE_HI
            else_end
            dec CURRENT_BUFFER_LINE_LO
        else_end
    next
        dec V38B3
        bne _loop
    end

    lda # BUMP_TOP - 1
    sta T5A
    jsr L21A2

    rts
.endproc

;;; summary: Command: Go top
;;; changed: ...
.proc CMD_GO_TOP
    lda CURRENT_BUFFER_HEAD
    sta CURRENT_BUFFER_B
    lda # BLOCK_OFFSET_POINTER_MIN_VALUE                    ; 3
    sta CURRENT_BUFFER_C
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        sec
        lda L1CE7
        sbc CURRENT_BUFFER_LINE_LO
;>>++
;clv
;<<++
        sta L1CE7
        lda L1CE8
        sbc CURRENT_BUFFER_LINE_HI
 ;>>++
clv
;<<++
       sta L1CE8
    else_end

    lda # 0
    sta CURRENT_BUFFER_LINE_LO
    sta CURRENT_BUFFER_LINE_HI
    jsr L21A2

    rts
.endproc

;;; summary: Command: Go bottom
;;; changed: ...
.proc CMD_GO_BOTTOM
    from_loop
        jsr L1982
        bcs _end                                            ; break

        bit G_MODE
        if_mi_then
            ; G_MODE = MODE_SELECT
            inc L1CE7
            if_eq_then
                inc L1CE8
            else_end
        else_end

        inc CURRENT_BUFFER_LINE_LO
        if_eq_then
            inc CURRENT_BUFFER_LINE_HI
        else_end
    next
        bne _loop
    end

    lda # BUMP_BOTTOM
    sta T5A
    jsr L21A2

    rts
.endproc

;;; summary: Command: Go to end of line
;;; changed: ...
.proc CMD_GO_END_LINE
    jsr L1982
    if_cc_then
        jsr L1C99                                           ; A- X- Y-
    else_end
    
    lda # BUMP_RIGHT
    sta CURSOR_SCREEN_X
    jsr L219D

    rts
.endproc

;;; summary: Command: Go to begin of line
;;; changed: ...
.proc CMD_GO_BEGIN_LINE
    jsr L1982
    if_cc_then
        jsr L19DD
    else_end

    jsr L219D

    rts
.endproc

;;; summary: Command: Open line
;;; changed: A+ ...
.proc CMD_ADD_LINE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end
    
    ; G_MODE = MODE_EDIT

    jsr L1982
    if_cc_then
        jsr L1C99                                           ; A- X- Y-
    else_end
    
    lda # PETSCII_RETURN
    jsr CMD_SPLIT_LINE

    rts
.endproc

.proc CMD_NOP
    rts
.endproc

;;; summary: Command: Insert
;;; changed: ...
.proc CMD_INSERT
    L366C:  rts
.endproc

.proc CMD_F7
    rts
.endproc

.proc CMD_F8
    rts
.endproc

;;; summary: JSR indirect to [DX]
;;; changed: A- X- Y- P-
.proc JSR_INDIRECT_DX
    jmp [DX]
    rts
.endproc

;;; summary: Compare nul-terminated strings
;;; in:
;;;   BX  Left string
;;;   CX  Right string
;;; out:
;;;   Z   Is equal?
;;; changed: A+  Y+
.proc STRING_COMPARE_BX_CX
    from
        ldy # 0
    loop
        lda [BX],y
        cmp [CX],y
        if_ne_then
            ; (A = [BX],y) != [CX],y
            rts
        else_end

        ; A = [BX],y = [CX],y
        ; A may be 0
        cmp # PETSCII_NUL
        beq _end                                            ; break
    next
        iny
        bne _loop                                           ; bra compare max 255/256
    end

    rts
.endproc

;;; summary: Compare nul-terminated strings with `X` significant characters
;;; in:
;;;   X   Number of significant characters
;;;   BX  Left string
;;;   CX  Right string
;;; out:
;;;   Z   Is equal?
;;; changed: A+  X+  Y+
.proc STRING_COMPARE_SIGNIFICANT_BX_CX_X
    from
        ldy # 0
    loop
        lda [BX],y
        cmp [CX],y
        if_ne_then
            rts
        else_end

        iny
        cmp # PETSCII_NUL
        beq _end                                            ; break
    next
        dex
        bne _loop
    end

    rts
.endproc

.proc CMD_PANIC
    php
        pha
            lda # COLOR_RED
            sta VIC_EC
        pla
    plp


    CMD_PANIC_INFINITE_LOOP:
    bvs CMD_PANIC_INFINITE_LOOP
    bvc CMD_PANIC_INFINITE_LOOP

    ; Does not come here
.endproc

;;; summary: Handle exception
;;; in: ZP_EXCEPTION_CODE
;;; out: V=0
;;; changed: A+ X+ Y? AX+
.proc HANDLE_EXCEPTION
    if_vc_then
        ; Should not get here when no exception -> panic
        brk
    else_end

    ; Clear exception
    clv

    ; Lookup exception message, display ,wait for <RETURN>
    ldx ZP_EXCEPTION_CODE
    lda MAP_EXCEPTION_CODE_TO_RESOURCE_STRING_LO,x
    sta AL
    lda MAP_EXCEPTION_CODE_TO_RESOURCE_STRING_HI,x
    sta AH
    ldx AL
    ldy AH
    jsr PRINT_STATUS_LINE

    rts
.endproc
