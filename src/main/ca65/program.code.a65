;    PEDSCII: Editor for the Commodore.
;    Copyright (C) 2025  C64PECTRE
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see https://www.gnu.org/licenses/.
;
;    Contact: https://github.com/c64pectre/pedscii/ create an issue

;;; summary: Main
;;; notes:
;;;   Stack:
;;;     | F4 | F5 F6      | F7 F8 | F9 FA FB FC FD FE FF |
;;;     | __ | 1E 08      | 46 E1 | E9 A7 A7 79 A6 9C E3 |
;;;     |    | ENTRYPOINT | KERNAL|
.proc main
    jsr INITIALIZE

    from_loop
        ldy T5B
        lda [ZPKERNAL_PNT],y
        pha
        jsr REVERSE_CURSOR_CHAR
        from_loop
            tya
            pha
            jsr KERNAL_GETIN
            bne _end                                        ; break ; We've got a char
            jsr L2017
            pla
            tay
            lda ZPKERNAL_TIME_2
            sec
            sbc PREVIOUS_ZPKERNAL_TIME_2
            cmp # CURSOR_BLINK_DELAY
            if_pl_then
                jsr REVERSE_CURSOR_CHAR
            else_end
        next
            jmp _loop
        end

        ; We've got a char in A
        tax
        pla
        tay
        pla
        sta [ZPKERNAL_PNT],y
        txa
        jsr PROCESS_CHAR
    next
        jmp _loop
    end

    ; Does not come here
    brk
.endproc

;;; summary reverse character under cursor
;;; changed: A
.proc REVERSE_CURSOR_CHAR
    lda [ZPKERNAL_PNT],y
    eor # $80
    sta [ZPKERNAL_PNT],y
    lda ZPKERNAL_TIME_2
    sta PREVIOUS_ZPKERNAL_TIME_2

    rts
.endproc

;;; summary: Add character in A to current cursor position, afterwards move 1 position to the right
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: A, X
.proc ADD_CHAR
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end

    ; G_MODE = MODE_EDIT

    cmp # PETSCII_NO_BREAK_SPACE
    if_eq_then
        lda # PETSCII_SPACE
    else_end

    ldx Z92
    cpx # MAX_LINE_LENGTH - 1
    if_eq_then
        rts
    else_end

    ldx P35
    cpx P36
    if_cc_then
        rts
    else_end

    jsr L1AE4                                               ; May throw EXCEPTION_OUT_OF_MEMORY
    if_cs_then
        rts
    else_end
    
    jsr L1B9C
    ldx P35
    inx
    stx P35
    stx P19
    inc Z92
    jsr L1BBC
    if_cs_then
        lda # PETSCII_RETURN
        jsr L1AE4                                           ; May throw EXCEPTION_OUT_OF_MEMORY
        if_cs_then
            jsr L1C99                                       ; A- X- Y-
            jsr L1BF7
            rts
        else
            inc T5B
            jsr L1BCB
            jsr L1982
            lda T4F
            sta V37D4
            lda T50
            sta V37D5
            jsr L1BD6
            inc V37D6
            jsr L219D

            rts
        end
    else
        lda T5B
        cmp # BUMP_RIGHT
        if_cs_then
            inc P36
            jsr SCROLL_RIGHT
            jsr L1A15
            rts
        else
            inc T5B
            jsr L1A15
            rts
        end
    end

    ; Does not come here
    brk
.endproc

;;; summary: Command: Delete (BACKSPACE)
;;; summary: A+ ...
.proc CMD_DELETE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end

    ; G_MODE = MODE_EDIT

    lda P35
    cmp P36
    if_cc_then
        rts
    else_end
    
    jsr L1C99                                               ; A- X- Y-
    if_cs_then
        rts
    else_end
    
    jsr L1BBC
    cmp # PETSCII_RETURN
    if_ne_then
        jsr L1BF7
        dec P35
        lda P35
        sta P19
        dec Z92
        jsr L19FD
        jsr L1A15
        jsr L19D0
        inx
        cpx T5B
        if_ne_then
            dec P36
            jsr SCROLL_LEFT
            rts
        else_end
        dec T5B

        rts
    else_end

    jsr L1BCB
    jsr L1B9C
    jsr L19DD
    jsr L1982
    stx V3781
    jsr L1982
    jsr L1BD6
    txa
    clc
    adc V3781
    if_cs_then
        jsr L1B9C
        rts
    else_end

    cmp # MAX_LINE_LENGTH
    if_cs_then
        jsr L1B9C
        rts
    else_end

    jsr L1B9C
    jsr L1BBC
    if_cs_then
        jsr L1C99                                           ; A- X- Y-
        jsr L1C99                                           ; A- X- Y-
        if_cc_then
            jsr L1BBC
            cmp # PETSCII_RETURN
            if_ne_then
                jsr L1B9C
                jsr L1B9C                                   ; TODO Why twice?
                rts
            else_end

            jsr L1B9C
        else_end

        jmp _end
    else
        jsr L1C99                                           ; A- X- Y-
    end

    lda P38
    if_eq_then
        dec P39
    else_end

    dec P38
    jsr L1BF7
    lda # BUMP_RIGHT
    sta T5B
    lda T5A
    cmp # PETSCII_RETURN
    if_cs_then
        jsr L2627
        jsr MOVE_CURSOR_UP                                  ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
        jsr L219D
        rts
    else_end

    jsr L268E
    if_cs_then
        jsr L2627
        jsr MOVE_CURSOR_UP                                  ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
    else_end

    jsr L219D

    rts
.endproc

;;; summary: ?
;;; return:
;;;   CS: CC:
;;; changed: X+ ...
.proc L1982
    ldx # 0
    jsr L1BBC
    if_cs_then
        rts
    else_end

    from_loop
        cmp # PETSCII_RETURN
        beq _end                                            ; break
        inx
        jsr L1B9C
        jsr L1BBC
    next
        jmp _loop
    end

    jsr L1B9C
    clc

    rts
.endproc

;;; summary: ?
;;; changed: A+ X+ Y+ ...
.proc L199D
    lda # <EDIT_PANEL_LAST_LINE_START_VM
    sta TFB
    lda # >EDIT_PANEL_LAST_LINE_START_VM
    sta TFC
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda L1CE8
        if_mi_then
            lda # EDIT_PANEL_LAST_LINE
            sec
            sbc T5A
            clc
            adc L1CE7
            lda # 0
            adc L1CE8
            if_mi_then
                lda # $80
                sta L2340
            else_end
        else_end
    else_end

    ldx V37D4
    ldy V37D5
    jsr L2290
    jsr L22B8

    rts
.endproc

;;; summary: ?
;;; changed: X+ ...
.proc L19D0
    jsr L1BCB
    jsr L1B9C
    jsr L19DD
    dex
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L19DD
    ldx # 0
    jsr L1C99                                               ; A- X- Y-
    if_cs_then
        rts
    else_end

    inx
    from_loop
        jsr L1C99                                           ; A- X- Y-
        if_cs_then
            clc
            rts
        else_end

        jsr L1BBC
        cmp # PETSCII_RETURN
        beq _end                                            ; break
    next
        inx
        jmp _loop
    end

    jsr L1B9C
    clc

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L19FD
    try
        jsr L1BCB
        from_loop
            jsr L1C99                                       ; A- X- Y-
            bcs _catch                                      ; throw
            jsr L1BBC
            cmp # PETSCII_RETURN
        next
            bne _loop
        end

        jsr L1B9C
    catch_finally_end

    jsr L1BE1
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1A15
    lda ZPKERNAL_PNT_LO
    sta TFB
    lda ZPKERNAL_PNT_HI
    sta TFC
    ldx T58
    ldy T59
    jsr L2290
    jsr L22B8
    jsr L2545

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1A2A
    try
        lda # 0
        sta T5B
        sta P35
        jsr L1BEC
        ldy # 0
        inx
        from_loop
            cpy P36
            beq _end                                        ; break
            dex
            beq _catch
            jsr L1BBC
            bcs _catch
            cmp # PETSCII_RETURN
            beq _catch
            iny
            jsr L1B9C
            inc P35
        next
            jmp _loop
        end

        from_loop
            dex
            beq _end
            jsr L1BBC
            bcs _catch
            cmp # PETSCII_RETURN
            beq _catch
            iny
            jsr L1B9C
        next
            inc T5B
            inc P35
            jmp _loop
        else_end

        jsr L1BCB
        from_loop
            jsr L1BBC
            bcs _end                                        ; break
            cmp # PETSCII_RETURN
            beq _end                                        ; break
            iny
            jsr L1B9C
        next
            jmp _loop
        end                                                 ; L1A79:

        jsr L1BD6
    catch_finally_end

    sty Z92

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1A7F
    lda # 0
    sta T5C
    ldx # >COMMAND_PANEL_FIRST_LINE_START_CR
    ldy # <COMMAND_PANEL_FIRST_LINE_START_CR
    bne L1A9B                                               ; bra
.endproc

;;; summary: Setup colors
;;; changed: ...
.proc L1A89
    ;>>
    ;--lda # COLOR_DGY
    ;--sta VIC_EC
    ;--lda # COLOR_GRY
    ;--sta VIC_B0C
    ;<<
    ldx # >COLOR_RAM_BASE
    ldy # <COLOR_RAM_BASE
    sty T5C
    ;--lda #COLOR_WHT
    lda KVAR_COLOR
.endproc

;;; summary: ?
;;; changed: ...
.proc L1A9B
    from_loop
        stx T5D
        from_loop
            cpy # <COMMAND_PANEL_FIRST_LINE_START_CR
            if_eq_then
                cpx # >COMMAND_PANEL_FIRST_LINE_START_CR
                if_eq_then
                    ;--lda # COLOR_BLK               ; Command color
                else_end
            else_end
            sta [T5C],y
        next
            iny
            bne _loop
        end
    next
        inx
        cpx # >(SCREEN_COLOR_RAM_BASE + SCREEN_COLOR_RAM_SIZE)
        bne _loop
    end

    rts
.endproc

;;; summary: Move cursor down
;;; changed: A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
.proc MOVE_CURSOR_DOWN
    lda ZPKERNAL_PNT_LO
    clc
    adc # VIC_CHAR_COLUMNS
    sta ZPKERNAL_PNT_LO
    lda ZPKERNAL_PNT_HI
    adc # 0
    sta ZPKERNAL_PNT_HI
    inc T5A

    rts
.endproc

;;; summary: Move cursor up
;;; changed: A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
.proc MOVE_CURSOR_UP
    lda ZPKERNAL_PNT_LO
    sec
    sbc # VIC_CHAR_COLUMNS
    sta ZPKERNAL_PNT_LO
    lda ZPKERNAL_PNT_HI
    sbc # 0
    sta ZPKERNAL_PNT_HI
    dec T5A

    rts
.endproc

;;; summary: Clear the last edit panel line
;;; changed: ...
.proc CLEAR_EDIT_PANEL_LAST_LINE
    ldx # <EDIT_PANEL_LAST_LINE_START_VM
    ldy # >EDIT_PANEL_LAST_LINE_START_VM
    stx T5C
    sty T5D
    from
        lda # PETSCII_SPACE
        ldy # VIC_CHAR_COLUMNS - 1
    loop
        sta [T5C],y
    next
        dey
        bpl _loop
    end

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc L1AE4
    sta L1B46
    tya
    pha
    ldy # 2                                                 ; ?
    lda [T4E],y
    cmp # $FF                                               ; ?
    if_eq_then
        jsr L1B77                                           ; May throw EXCEPTION_OUT_OF_MEMORY
        if_cs_then
            pla
            rts
        else_end
        sta L1B47
    else_end

    lda V37D4
    cmp T4F
    if_eq_then
        inc V37D5
    else_end

    ldy # 2                                                ; ?
    lda [T4E],y
    tay
    iny
    from_loop
        dey
        lda [T4E],y
        iny
        if_eq_then
            jsr L1B48
            ldy V37D5
            if_eq_then
                lda T23
                sta V37D4
                lda # 3
                sta V37D5
            else_end

            ldy # 0
            jmp _end
        else
            sta [T4E],y
        end
    next
        dey
        cpy T50
        bne _loop
    end

    lda L1B46
    sta [T4E],y
    ldy # 2                                                ; ?
    lda [T4E],y
    clc
    adc # 1
    if_ne_then
        sta [T4E],y
    else_end

    pla
    tay
    lda L1B46
    clc

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1B48
    pha
    lda [T4E],y
    pha
    if_ne_then
        sta T23
        lda L1B47
        iny
        sta [T22],y
        dey
        jmp _end
    else
        lda L1B47
    end
    
    sta [T4E],y
    sta T23
    lda [T22],y
    sta ZP_0E
    pla
    sta [T22],y
    lda T4F
    iny
    sta [T22],y
    lda # 3                                                ; ?
    iny
    sta [T22],y
    pla
    iny
    sta [T22],y

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc L1B77
    clc
    lda ZP_0E
    if_eq_then
        from_loop
            jsr L2017
        next
            bcs _loop
        end

        lda ZP_0E
        if_eq_then
            ; Show "out of memory"
            ldx # <RESOURCE_STRING_OUT_OF_MEMORY
            ldy # >RESOURCE_STRING_OUT_OF_MEMORY
            jsr PRINT_STATUS_LINE
            sec
        else_end
    else_end
    
    rts
.endproc

;;; summary:
;;; changed: A-, Y-
.proc L1B9C
    pha
    tya
    pha
    lda T50
    ldy # 2
    cmp [T4E],y
    if_cs_then
        ldy # 0
        lda [T4E],y
        if_ne_then
            sta T4F
            lda # 3
            sta T50
        else_end
        jmp _end
    else
        inc T50
    end

    pla
    tay
    pla

    rts
.endproc

;;; summary: C:= [T4E],T50 == 0
;;; changed: A+
.proc L1BBC
    sty L1B46                                               ; Backup Y
    ldy T50
    lda [T4E],y
    clc
    if_eq_then
        sec
    else_end
    ldy L1B46                                               ; Restore Y

    rts
.endproc

;;; summary: T52#T53 := T4F#T50
;;; changed: A- X- Y- T52:=T4F T53:=T50
.proc L1BCB
    pha
        lda T4F
        sta T52
        lda T50
        sta T53
    pla

    rts
.endproc

;;; summary: T4F#T50 := T52#T53
;;; changed: A- X- Y-
.proc L1BD6
    pha
        lda T52
        sta T4F
        lda T53
        sta T50
    pla

    rts
.endproc

;;; summary: T58#T59 := T4F#T50 
;;; changed: A- X- Y-
.proc L1BE1
    pha
        lda T4F
        sta T58
        lda T50
        sta T59
    pla

    rts
.endproc

;;; summary: T4F#T50 := T58#T59
;;; changed: A- X- Y-
.proc L1BEC
    pha
        lda T58
        sta T4F
        lda T59
        sta T50
    pla

    rts
.endproc

;;; summary: ?
;;; changed: A- X- Y-
.proc L1BF7
    pha
        txa
        pha
            tya
            pha
                lda V37D4
                cmp T4F
                if_eq_then
                    dec V37D5
                else_end

                ldy # 2
                lda [T4E],y
                tax
                cmp T50
                if_eq_then
                    lda [T4E],y
                    sec
                    sbc # 1
                    sta [T4E],y
                    ldy T4F
                    jsr L1B9C
                    txa
                    cmp # 3
                    bne L1C27
                    tya
                    jsr L1C55
                    jmp L1C39
                    L1C27:
                    ldy # 2
                    lda [T57],y
                    cmp T59
                    bcs L1C39
                    ldy # 0
                    lda [T57],y
                    sta T58
                    lda # 3
                    sta T59
                    L1C39:
                    jmp _end
                else
                    lda [T4E],y
                    sec
                    sbc # 1
                    sta [T4E],y
                    from
                        ldy T50
                        iny
                    loop
                        lda [T4E],y
                        dey
                        sta [T4E],y
                    next
                        iny
                        iny
                        bne _loop
                    end
                end
            pla
            tay
        pla
        tax
    pla

    rts
.endproc

;;; summary: ?
;;; changed: A- X+ Y+
.proc L1C55
    ldy # 0
    sta T23
    cmp V37D7
    if_eq_then
        lda [T22],y
        sta V37D7
        lda # 3
        sta V37D8
    else_end

    lda [T22],y
    if_eq_then
        iny
        lda [T22],y
        jmp _end
    else
        sta T27
        iny
        lda [T22],y
        sta [T26],y
    end

    if_eq_then
        lda T27
        sta ZPBASIC_VALTYP
        ldx ZPKERNAL_CMP0
        sta V37D9,x
        jmp _end
    else
        sta T27
        dey
        lda [T22],y
        sta [T26],y
    end

    lda ZP_0E
    ldy # 0
    sta [T22],y
    lda T23
    sta ZP_0E

    rts
.endproc

;;; summary: ?
;;; changed: A- X- Y-
.proc L1C99
    pha
        tya
        pha
            lda T50
            cmp # 3
            if_eq_then
                ldy # 1
                lda [T4E],y
                if_eq_then
                    sec
                    jmp _end
                else
                    sta T4F
                    iny
                    lda [T4E],y
                    sta T50
                    clc
                end
                jmp _end
            else
                dec T50
                clc
            end
        pla
        tay
    pla

    rts
.endproc

;;; summary: Command: Enter select mode for cut <SHIFT + STOP_RUN>
;;; changed: ...
.proc CMD_SELECT_MODE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        ; End select mode, back to edit mode
        inc G_MODE
        ; G_MODE = MODE_EDIT
        jsr L219D

        rts
    else_end

    ; check G_MODE = MODE_EDIT

    jsr L1BBC
    if_cc_then
        dec G_MODE
        ; G_MODE = MODE_SELECT
        lda T58
        sta L1CE5
        lda T59
        sta L1CE6
        lda #$00
        sta L1CE7
        sta L1CE8
    else_end

    rts
.endproc

;;; summary: Command: Cut <F5>
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc CMD_CUT
    bit G_MODE
    if_pl_then
        ; G_MODE = MODE_EDIT
        rts
    else_end

    ; G_MODE = MODE_SELECT

    inc G_MODE
    ; G_MODE = MODE_EDIT

    lda # 1
    jsr L26DA
    lda # 0
    sta TFB
    sta PFD
    jsr L1B77                                               ; May throw EXCEPTION_OUT_OF_MEMORY
    if_cs_then
        rts
    else_end
    
    sta L1EE6
    sta TFC
    ldy # 0
    lda [TFB],y
    sta ZP_0E
    jsr L1B77                                               ; May throw EXCEPTION_OUT_OF_MEMORY
    if_cs_then
        lda L1EE6
        sta ZP_0E
        rts
    else_end
    
    sta L1EE7
    jsr L1BCB
    lda L1CE8
    if_pl_then
        sta L1CEA
        lda L1CE7
        sta L1CE9
        lda L1CE5
        sta T4F
        lda L1CE6
        sta T50
        lda T58
        sta V37D4
        lda T59
        sta V37D5
        jmp _end
    else
        eor # $FF
        sta L1CEA
        lda L1CE7
        eor # $FF
        sta L1CE9
        inc L1CE9
        if_eq_then
            inc L1CEA
        else_end

        lda L1CE5
        sta T4F
        lda L1CE6
        sta T50
        jsr L1982
        lda T4F
        sta V37D4
        lda T50
        sta V37D5
        jsr L1BD6
        jsr L1982
    end

    lda L1CE8
    if_pl_then
        sec
        lda P38
        sbc L1CE9
        sta P38
        lda P39
        sbc L1CEA
        sta P39
        jmp _end
    else
        inc P38
        if_eq_then
            inc P39
        else_end
    end

    lda L1EE6
    sta TFC
    ldx # 1
    sta V37D9,x
    sta V37E3,x
    lda # 3
    sta V37ED,x
    lda T4F
    cmp V37D4
    if_eq_then
        jsr L1E80
        rts
    else_end

    ldy # 0
    lda L1EE7
    sta PFE
    lda [PFD],y
    sta ZP_0E
    lda [T4E],y
    sta [TFB],y
    sta PFE
    tya
    iny
    sta [TFB],y
    lda TFC
    sta [PFD],y
    iny
    lda [T4E],y
    sec
    sbc T50
    clc
    adc # 3
    sta [TFB],y
    ldy T50
    dey
    sty L1EE3
    ldy # 2
    sty L1EE4
    from_loop
        inc L1EE3
        inc L1EE4
        ldy L1EE3
        lda [T4E],y
        ldy L1EE4
        sta [TFB],y
        ldy # 2
        lda [T4E],y
        cmp L1EE3
    next
        bne _loop
    end

    lda L1EE7
    sta PFE
    lda V37D4
    sta TFC
    ldy # 0
    lda [TFB],y
    sta [PFD],y
    ldy # 2
    lda [TFB],y
    sec
    sbc V37D5
    clc
    adc # 3
    sta [PFD],y
    ldy V37D5
    dey
    sty L1EE3
    ldy # 2
    sty L1EE4
    from_loop
        inc L1EE3
        inc L1EE4
        ldy L1EE3
        lda [TFB],y
        ldy L1EE4
        sta [PFD],y
    next
        ldy # 2
        lda [TFB],y
        cmp L1EE3
        bne _loop
    end

    ldy # 2
    lda V37D5
    sta [TFB],y
    tay
    lda # 0
    sta [TFB],y
    tay
    sta [TFB],y
    ldy # 1
    lda T4F
    sta [PFD],y
    dey
    lda PFE
    sta [T4E],y
    lda [PFD],y
    if_ne_then
        sta TFC
        lda PFE
        iny
        sta [TFB],y
    else_end

    lda T50
    cmp # 3
    if_eq_then
        lda T4F
        jsr L1C55
        jmp _end
    else
        sec
        sbc # 1
        ldy # 2
        sta [T4E],y
    end

    lda PFE
    sta T4F
    lda # 3
    sta T50
    jsr L21A2

    rts
.endproc

;;; summary: Command: Select all
.proc CMD_SELECT_ALL
    ; TODO
    rts
.endproc

;;; summary: Command: Copy
.proc CMD_COPY
    ; TODO
    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1E80
    from
        ldy T50
        sty L1EE3
        ldy # 3
        sty L1EE4
    loop
        ldy L1EE3
        lda [T4E],y
        ldy L1EE4
        sta [TFB],y
        inc L1EE3
        inc L1EE4
        lda L1EE3
        cmp V37D5
        bne _loop
    end

    lda # 0
    tay
    sta [TFB],y
    iny
    sta [TFB],y
    lda L1EE4
    iny
    sta [TFB],y
    tay
    lda # 0
    sta [TFB],y

    from
        ldy V37D5
        dey
        sty L1EE3
        ldy T50
        dey
        sty L1EE4
    loop
        inc L1EE3
        inc L1EE4
        ldy L1EE3
        lda [T4E],y
        ldy L1EE4
        sta [T4E],y
        ldy # 2
        lda [T4E],y
        cmp L1EE3
        bne _loop
    end

    lda     L1EE4
    sta     [T4E],y
    jsr     L21A2

    rts
.endproc

;;; summary: Command: Paste
;;; throws: EXCEPTION_OUT_OF_MEMORY, EXCEPTION_NOT_ENOUGH_MEMORY
;;; changed: ...
.proc CMD_PASTE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end

    ; G_MODE = MODE_EDIT

    ldx # 1
    lda V37D9,x
    jsr L1FFE
    sta L1EE5
    inc L1EE5
    lda ZP_0E
    jsr L1FFE
    cmp L1EE5
    if_cc_then
        ; Show "not enough memory"
        ldx # <RESOURCE_STRING_NOT_ENOUGH_MEMORY
        ldy # >RESOURCE_STRING_NOT_ENOUGH_MEMORY
        jsr PRINT_STATUS_LINE
        rts
    else_end

    jsr L1BEC
    clc
    lda P38
    adc L1CE9
    sta P38
    lda P39
    adc L1CEA
    sta P39
    lda # 0
    sta TFB
    sta PFD
    tay
    lda [T4E],y
    pha
    lda T4F
    sta TFC
    ldx # 1
    lda V37D9,x
    if_eq_then
        pla
        rts
    else_end

    from_loop
        sta PFE
        lda TFC
        pha
        jsr L1B77                                           ; May throw EXCEPTION_OUT_OF_MEMORY
        ldy # 0
        sta [TFB],y
        sta TFC
        lda [TFB],y
        sta ZP_0E
        pla
        iny
        sta [TFB],y
        iny
        from_loop
            lda [PFD],y
            sta [TFB],y
        next
            iny
            bne _loop
        end
    next
        lda [PFD],y
        bne _loop
    end

    lda TFC
    sta L1EE5
    jsr L1B77                                               ; May throw EXCEPTION_OUT_OF_MEMORY
    ldy # 0
    sta [TFB],y
    sta TFC
    lda [TFB],y
    sta ZP_0E
    lda L1EE5
    iny
    sta [TFB],y
    pla
    dey
    sta [TFB],y
    cmp # 0
    if_ne_then
        sta PFE
        lda TFC
        iny
        sta [PFD],y
    else_end

    from
        ldy T50
        dey
        sty L1EE3
        ldy # 2
        sty L1EE4
    loop
        inc L1EE3
        inc L1EE4
        ldy L1EE3
        lda [T4E],y
        ldy L1EE4
        sta [TFB],y
    next
        ldy # 2
        lda [T4E],y
        cmp L1EE3
        bne _loop
    end

    lda L1EE4
    sta [TFB],y
    lda T50
    cmp # 3
    if_eq_then
        lda T4F
        jsr L1C55
        jmp _end
    else
        sec
        sbc # 1
        ldy # 2
        sta [T4E],y
    end

    lda TFC
    sta T4F
    lda # 3
    sta T50
    lda L1EE5
    sta PFE
    ldy # 2
    lda [PFD],y
    cmp # 3
    if_eq_then
        lda PFE
        jsr L1C55
        jmp _end
    else
        sec
        sbc # 1
        sta [PFD],y
    end

    lda T5A
    cmp # BUMP_TOP - 1
    if_cc_then
        lda # BUMP_TOP - 1
        sta T5A
    else_end

    jsr L21A2

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L1FFE
    cmp # 0
    if_eq_then
        rts
    else_end

    sta TFC
    lda # 0
    sta TFB
    tax
    tay
    from_loop
        inx
        lda [TFB],y
        beq _end                                            ; break
        sta TFC
    next
        jmp _loop
    end

    txa

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2017
    lda # 0
    sta T5C
    sta T5E
    sta V3787
    L2020:
    sta V3788
    sta V3789
    sta V378A
    sta V378B
    lda ZPBASIC_VALTYP
    pha
    from_loop
        pla
        sta T5D
        ldy # 0
        lda [T5C],y
        if_eq_then
            clc
            rts
        else_end
    next
        pha
        ldy # 2
        lda [T5C],y
        cmp # $FF
        beq _loop
    end

    sta V3783
    inc V3783
    pla
    sta T5F
    cmp T4F
    if_eq_then
        inc V3787
    else_end

    cmp T58
    if_eq_then
        inc V3788
    else_end

    cmp V37D7
    if_eq_then
        inc V3789
    else_end

    cmp V37D4
    if_eq_then
        inc V378A
    else_end

    cmp L1CE5
    if_eq_then
        inc V378B
    else_end

    from
        ldy # 2
        lda [T5E],y
        sta V3785
        ldy # 3
        sty V3784
    loop
        ldy V3784
        lda [T5E],y
        ldy V3783
        sta [T5C],y
        lda V3787
        if_ne_then
            lda T50
            cmp V3784
            if_eq_then
                lda T5D
                sta T4F
                sty T50
                dec V3787
            else_end
        else_end

        lda V3788
        if_ne_then
            lda T59
            cmp V3784
            if_eq_then
                lda T5D
                sta T58
                sty T59
                dec V3788
            else_end
        else_end

        lda V3789
        if_ne_then
            lda V37D8
            cmp V3784
            if_eq_then
                lda T5D
                sta V37D7
                sty V37D8
                dec V3789
            else_end
        else_end

        lda V378A
        if_ne_then
            lda V37D5
            cmp V3784
            if_eq_then
                lda T5D
                sta V37D4
                sty V37D5
                dec V378A
            else_end
        else_end

        lda V378B
        if_ne_then
            lda L1CE6
            cmp V3784
            if_eq_then
                lda T5D
                sta L1CE5
                sty L1CE6
                dec V378B
            else_end
        else_end

        lda V3784
        cmp V3785
        if_eq_then
            lda T5F
            jsr L1C55
            ldy # 2
            lda V3783
            sta [T5C],y
            clc
            rts
        else_end
    next
        inc V3784
        inc V3783
        beq _end
        jmp _loop
    end

    from
        lda # $FF
        ldy # 2
        sta [T5C],y
        iny
        sty V3783
        lda V3784
        sec
        sbc # 3
        sta V3786
        inc V3785
        ldy V3784
    loop
        lda [T5E],y
        ldy V3783
        sta [T5E],y
    next
        inc V3783
        inc V3784
        ldy V3784
        cpy V3785
        bne _loop
    end

    lda V3787
    if_ne_then
        lda T50
        sec
        sbc V3786
        sta T50
    else_end

    lda V3788
    if_ne_then
        lda T59
        sec
        sbc V3786
        sta T59
    else_end

    lda V3789
    if_ne_then
        lda V37D8
        sec
        sbc V3786
        sta V37D8
    else_end

    lda V378A
    if_ne_then
        lda V37D5
        sec
        sbc V3786
        sta V37D5
    else_end

    lda V378B
    if_ne_then
        lda L1CE6
        sec
        sbc V3786
        sta L1CE6
    else_end

    lda V3785
    clc
    sbc V3786
    ldy # 2
    sta [T5E],y
    sec

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L219D
    lda # 0
    pha
    beq L21A5                                               ; bra
.endproc

;;; summary: ?
;;; changed: ...
.proc L21A2
    lda # 1
    pha
.endproc

;;; summary: ?
;;; changed: ...
.proc L21A5
    jsr L1BCB
    jsr L1BBC
    if_cc_then
        jsr L1B9C
        jsr L19DD
        dex
        jmp _end
    else
        ldx # 0
    end

    stx P35
    stx P19
    txa
    sec
    sbc T5B
    if_cc_then
        lda P35
        sta T5B
        lda # 0
    else_end

    sta P36
    jsr L1BE1
    jsr L1982
    stx Z92
    pla
    pha
    if_ne_then
        jsr L1BEC
        jsr L34FF
    else_end

    jsr L333B                                               ; A+ L3380+ L337F+
    lda # >COLOR_RAM_BASE
    sta TFB
    lda # >(OUR_VIDEO_MATRIX_BASE - 1)
    sta TFC
    lda # <(OUR_VIDEO_MATRIX_BASE - 1)
    sta PFE
    ldx V37D7
    ldy V37D8
    jsr L2290
    try
        from_loop
            lda TFB
            clc
            adc # VIC_CHAR_COLUMNS
            sta TFB
            if_cs_then
                inc TFC
            else_end

            inc PFE
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                lda PFE
                cmp L337F
                if_cs_then
                    cmp L3380
                    if_cc_then
                        lda # $80
                        sta L2340
                    else_end
                else_end
            else_end

            jsr L22B8
            bcs _catch
        next
            lda PFE
            cmp # EDIT_PANEL_LAST_LINE
            bne _loop
        end

        clc
    catch_finally_end

    pla
    pha
    if_ne_then
        if_cc_then
            lda Z97
            sta T4F
            stx T50
            jsr L19DD
            lda T4F
            sta V37D4
            lda T50
            sta V37D5
            jmp _end
        else
            lda Z97
            sta V37D4
            stx V37D5
        end

        lda PFE
        sta V37D6
    else_end

    from_loop
        lda PFE
        cmp # EDIT_PANEL_LAST_LINE
        beq _end                                            ; break
        clc
        lda TFB
        adc # VIC_CHAR_COLUMNS
        sta TFB
        if_cs_then
            inc TFC
        else_end

        lda # PETSCII_SPACE
        ldy # VIC_CHAR_COLUMNS - 1
        from_loop
            sta [TFB],y
        next
            dey
            bpl _loop
        end
    next
        inc PFE
        jmp _loop
    end

    jsr L1BD6
    pla
    if_ne_then
        lda # 0
        sta ZPKERNAL_PNT_HI
        lda T5A
        asl
        asl
        adc T5A
        asl
        asl
        rol ZPKERNAL_PNT_HI
        asl
        rol ZPKERNAL_PNT_HI
        sta ZPKERNAL_PNT_LO
        lda ZPKERNAL_PNT_HI
        adc # >OUR_VIDEO_MATRIX_BASE
        sta ZPKERNAL_PNT_HI
    else_end

    jsr L2545

    rts
.endproc

;;; summary: ?
;;; changed: A+ X=Y' Y=2
.proc L2290
    lda # 0
    sta T5C
    sta Z96

    stx T5D
    stx Z97

    tya
    tax
    ldy # 2
    lda [T5C],y
    sta V378C

    rts
.endproc

;;; summary: ?
;;; parameters:
;;;   X: ?
;;; return:
;;;   X: ?
;;; changed: ...
.proc L22B8
    ; Note: A & Y are free to use here.
    txa
    tay
    lda [Z96],y

    if_eq_then
        ; A == 0
        txa
        pha
            ; Show "[bottom]"
            ldx # <RESOURCE_STRING_BOTTOM
            ldy # >RESOURCE_STRING_BOTTOM
            jsr PRINT_FILL_LINE                             ; A+ X- Y+
        pla
        tax
        sec
        rts
    else_end
    
    ldy P36
    ;if_ne_then
        beq L22E6
        ;from_loop
            L22CE:
            sty Z9B
                txa
                tay
                lda [Z96],y
            ldy Z9B

            cmp # PETSCII_RETURN
            if_eq_then
                ldy # 0
                jmp L2319                                   ; break break
            else_end

            cpx V378C
            if_eq_then
                jsr L2341
            else_end
        ;next
            inx
            dey
            bne L22CE
        ;end
    ;else_end
    L22E6:

    ;from_loop
        sty Z9B
            txa
            tay
            lda [Z96],y
        ldy Z9B

        cmp # PETSCII_RETURN
        beq L2319                                           ; break
        cpy # VIC_CHAR_COLUMNS
        ;if_eq_then
            bne L2304
            ;from_loop
                L22F1:
                cpx V378C
                if_cs_then
                    jsr L2341
                else_end

                inx
                sty Z9B
                    txa
                    tay
                    lda [Z96],y
                ldy Z9B
            ;next
                cmp # PETSCII_RETURN
                bne L22F1
            ;end

            jmp L2319                                       ; break
        ;else
            L2304:
            jsr L240D                                       ; A+, V378D+
            eor L2340
            sta [TFB],y
            iny
            cpx V378C
            if_cs_then
                jsr L2341
            else_end
        ;end
    ;next
        inx
        jmp L22E6                                           ; _loop
    ;end
    L2319:

    cpx V378C
    if_cs_then
        jsr L2341
    else_end

    inx
    from
        lda # PETSCII_SPACE
        eor L2340
    loop
        cpy # VIC_CHAR_COLUMNS
        beq _end                                            ; break
        sta [TFB],y
    next
        iny
        bne _loop
    end

    lda # 0
    sta L2340
    clc

    rts
.endproc

;;; summary: ?
;;; changed:
;;;   A+  X=2  Y-
;;;   L22BA := L22D0 := L22E8 := L22FC := T5D := Z97 := [T5C],0
;;;   V378C := [T5C],2
.proc L2341
    tya
    pha
        ldy # 0
        lda [T5C],y
        sta T5D
        sta Z97

        ldy # 2
        lda [T5C],y
        sta V378C
        ldx # 2
    pla
    tay

    rts
.endproc

;;; summary: Print null terminated string in X#Y to T5C#T5D right fill the line with spaces.
;;; return:
;;;   Y: index 1 after character in line.
;;; changed: A+ X- Y+ T5C+ T5D+
.proc PRINT_FILL_LINE
    from
        stx T5C
        sty T5D
        ldy # 0
    loop
        lda [T5C],y
        beq _end                                            ; break
        jsr L240D                                           ; A+, V378D+
        sta [TFB],y
    next
        iny
        bne _loop
    end

    tya
    pha
    from
        lda # PETSCII_SPACE
    loop
        cpy # VIC_CHAR_COLUMNS
        beq _end                                            ; break
        sta [TFB],y
    next
        iny
        bne _loop
    end

    pla
    tay

    rts
.endproc

;;; summary: Command: Split line (insert/add return)
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc CMD_SPLIT_LINE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end

    ; G_MODE = MODE_EDIT

    jsr L1AE4                                               ; May throw EXCEPTION_OUT_OF_MEMORY
    if_cs_then
        rts
    else_end

    jsr L1B9C
    lda T5A
    cmp # BUMP_BOTTOM
    if_cc_then
        jsr MOVE_CURSOR_DOWN                                ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
        jsr L2649
        jmp _end
    else
        jsr L2671
    end

    lda # 0
    sta T5B
    inc P38
    if_eq_then
        inc P39
    else_end

    jsr L219D

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L23B1
    lda # >OUR_VIDEO_MATRIX_BASE
    sta T5D
    sta T5F
    lda # <OUR_VIDEO_MATRIX_BASE
    sta T5C
    lda # VIC_CHAR_COLUMNS
    sta T5E
    ldx # EDIT_PANEL_LAST_LINE
    from_loop
        from
            ldy # VIC_CHAR_COLUMNS - 1
        loop
            lda [T5E],y
            sta [T5C],y
        next
            dey
            bpl _loop
        end

        lda T5F
        sta T5D
        lda T5E
        sta T5C
        clc
        adc # VIC_CHAR_COLUMNS
        sta T5E
        if_cs_then
            inc T5F
        else_end
    next
        dex
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L23DF
    from
        lda # <EDIT_PANEL_LAST_LINE_START_VM
        sta T5C
        lda # <EDIT_PANEL_BEFORE_LAST_LINE_START_VM
        sta T5E
        lda # >EDIT_PANEL_LAST_LINE_START_VM
        sta T5D
        sta T5F
        ldx # EDIT_PANEL_LAST_LINE
    loop
        from
            ldy # VIC_CHAR_COLUMNS - 1
        loop
            lda [T5E],y
            sta [T5C],y
        next
            dey
            bpl _loop
        end

        lda T5F
        sta T5D
        lda T5E
        sta T5C
        clc
        adc # >COLOR_RAM_BASE
        sta T5E
        if_cc_then
            dec T5F
        else_end
    next
        dex
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: A+, V378D+
.proc L240D
    pha
        and # $7F                                           ; Clear reverse bit?
        cmp # PETSCII_SPACE
        ; A < $20  -> C=0
        ; A >= $20 -> C=1
        ror V378D
    pla
    asl
    ror V378D
    asl
    asl V378D
    ror
    asl V378D
    ror
    eor # $80
    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2426
    lda # <COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFB
    lda # >COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFC
    jsr PRINT_FILL_LINE                                     ; A+ X- Y+
    from
        ldx # 0
    loop
        jsr L247D
        jsr L24E6
        cmp # PETSCII_DELETE
        if_eq_then
            cpx # 0
            if_ne_then
                dex
                dey
                lda # PETSCII_SPACE
                sta [TFB],y
            else_end

            jmp _end
        else
            pha
            lda L24E5
            if_ne_then
                ;beq L2464
                pla
                cmp # CMD_KEY_SEARCH_DOWN
                if_eq_then
                    sta V378E,x
                    rts
                else_end

                cmp # CMD_KEY_SEARCH_UP
                if_eq_then
                    sta V378E,x
                    rts
                else_end

                jmp L246C
            else_end

            pla
            cmp # PETSCII_RETURN
            if_eq_then
                jmp L249D
            else_end

    L246C:

            cpy # VIC_CHAR_COLUMNS - 1
            if_ne_then
                sta V378E,x
                jsr L240D                                   ; A+, V378D+
                sta [TFB],y
                inx
                iny
            else_end
        end
    next
        jmp _loop
    end
    
    
    L247D:

    tya
    pha
        ldy # 0
        cpx # 0
        if_ne_then
            lda V378E
            cmp # PETSCII_LATIN_LETTER_A
            if_cc_then
                ldy #$01
                jmp L2497
            else_end

            cmp # PETSCII_LATIN_LETTER_Z + 1
            if_cs_then
                ldy # 1
            else_end
        else_end

        L2497:
        sty L24E5
    pla
    tay
    rts

    L249D:
    cpx # 0
    if_ne_then
        from_loop
            dex
            lda V378E,x
            cmp # PETSCII_QUOTATION_MARK
            beq L24AE
        next
            cmp # PETSCII_SPACE
            beq _loop
        end

        inx
    else_end
    
    L24AE:
    lda # 0
    sta V378E,x
    sta V37B1
    from
        ldx # $FF
    loop
        inx
        lda V378E,x
        if_eq_then
            rts
        else_end

        cmp # PETSCII_SPACE
        bne _loop
    end

    lda # 0
    sta V378E,x
    from_loop
        inx
        lda V378E,x
        bne L24CF
        rts
        L24CF:

        cmp # PETSCII_QUOTATION_MARK
        beq L24D8
        cmp # PETSCII_SPACE
        beq _loop
    end

    dex
    L24D8:
    from
        ldy # $FF
    loop
        inx
        iny
        lda V378E,x
        sta V37B1,y
    next
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L24E6
    stx L251F
    jsr L2521
    try
        from_loop
            tya
            pha
            jsr KERNAL_GETIN
            if_ne_then
                cmp # PETSCII_SPACE
                bne _catch
                ldx L251F
                bne _catch
            else_end

            pla
            tay
            lda ZPKERNAL_TIME_2
            sec
            sbc L251E
            cmp # CURSOR_BLINK_DELAY
            if_pl_then
                jsr L2521
            else_end
        next
            jmp _loop
        end
    catch_finally_end

    sta L2520
    pla
    tay
    ldx L251F
    lda # PETSCII_SPACE
    sta [TFB],y
    lda L2520

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2521
    lda [TFB],y
    eor # $80
    sta [TFB],y
    lda ZPKERNAL_TIME_2
    sta L251E

    rts
.endproc

;;; summary: Show X#Y on command/status line 
;;; changed: TFB, TFC
.proc PRINT_STATUS_LINE
    lda # <COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFB
    lda # >COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFC
    jsr PRINT_FILL_LINE                                     ; A+ X- Y+
    jsr KERNAL_CLRCHN
    from_loop
        jsr L24E6
    next
        cmp # PETSCII_RETURN
        bne _loop
    end

    jsr L2545

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2545
    from
        lda ZPKERNAL_CMP0
        ; A := 8 * A
        asl
        asl
        asl
        tay
        ldx # 0
    loop
        lda BUFFER_NAME_TABLE,y
        beq _end                                            ; break
        sta L259D,x
    next
        iny
        inx
        bne _loop
    end

    from
        lda # PETSCII_SPACE
    loop
        sta L259D,x
    next
        inx
        cpx # BUFFER_NAME_TABLE_ENTRY_SIZE
        bne _loop
    end

    ldx P38
    ldy P39
    inx
    if_eq_then
        iny
    else_end

    jsr INT_TO_STRING
    from
        ldx # 3
    loop
        lda INT_TO_STRING_RESULT,x
        sta L25B1,x
    next
        dex
        bpl _loop
    end

    ldx     P35
    inx
    ldy     # 0
    jsr     INT_TO_STRING
    from
        ldx # 2
    loop
        lda INT_TO_STRING_RESULT,x
        sta L25BE,x
    next
        dex
        bpl _loop
    end

    lda # <COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFB
    lda # >COMMAND_PANEL_FIRST_LINE_START_VM
    sta TFC
    ; Show/update status line
    ldx # <STATUS_LINE_CONTENT
    ldy # >STATUS_LINE_CONTENT
    jsr PRINT_FILL_LINE                                     ; A+ X- Y+

    rts
.endproc

;;; summary: X#Y (assuming in [0,9999] to string at INT_TO_STRING_RESULT
;;; notes:
;;;    If X#Y == 10.000 then you get ":000" etc
;;; changed: BX
.proc INT_TO_STRING
    stx BL
    sty BH
    ; Clear INT_TO_STRING_RESULT
    from
        ldx # INT_TO_STRING_DIGIT_COUNT - 1
        lda # PETSCII_SPACE
    loop
        sta INT_TO_STRING_RESULT,x
    next
        dex
        bpl _loop
    end

    from
        ldx # 0
        ldy # INT_TO_STRING_DIGIT_COUNT - 1
    loop
        from
            lda # 0
            sta CH
        loop
            sec
            lda BL
            sbc TABLE_POWER_OF_10_LO,y
            sta CL
            lda BH
            sbc TABLE_POWER_OF_10_HI,y
            bcc _end                                        ; break
            sta BH
            lda CL
            sta BL
        next
            inc CH
            bne _loop
        end

        lda CH
        bne L2604
        cpx # 0
        beq L260B
        L2604:
        clc
        adc # PETSCII_DIGIT_ZERO
        sta INT_TO_STRING_RESULT,x
        inx
        L260B:
    next
        dey
        bpl _loop
    end

    txa
    if_eq_then
        lda # PETSCII_DIGIT_ZERO
        sta INT_TO_STRING_RESULT
    else_end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2627
    jsr L1BCB
    lda V37D4
    sta T4F
    lda V37D5
    sta T50
    jsr L1982
    if_cs_then
        dec V37D6
    else_end

    lda T4F
    sta V37D4
    lda T50
    sta V37D5
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2649
    lda V37D6
    cmp # EDIT_PANEL_LAST_LINE
    if_ne_then
        inc V37D6
        rts
    else_end

    jsr L1BCB
    lda V37D4
    sta T4F
    lda V37D5
    sta T50
    jsr L19DD
    lda T4F
    sta V37D4
    lda T50
    sta V37D5
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2671
    jsr L1BCB
    lda V37D7
    sta T4F
    lda V37D8
    sta T50
    jsr L1982
    lda T4F
    sta V37D7
    lda T50
    sta V37D8
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L268E
    jsr L1BCB
    lda V37D7
    sta T4F
    lda V37D8
    sta T50
    jsr L19DD
    lda T4F
    sta V37D7
    lda T50
    sta V37D8
    jsr L1BD6

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L26AB
    tax
    lda L272B
    sta V37D9,x
    sta V37E3,x
    sta TFC
    lda # 0
    sta TFB
    tay
    lda [TFB],y
    sta ZP_0E
    tya
    sta [TFB],y
    iny
    sta [TFB],y
    lda # 3
    iny
    sta [TFB],y
    sta V37ED,x
    lda # 0
    sta V37F7,x
    sta V3801,x
    iny
    sta [TFB],y

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc L26DA
    tax
    lda V37D9,x
    if_eq_then
        rts
    else_end

    sta TFC
    lda # 0
    sta TFB
    sta V37D9,x
    tay

    from_loop
        lda [TFB],y
        pha
        lda ZP_0E
        sta [TFB],y
        lda TFC
        sta ZP_0E
        pla
        sta TFC
    next
        bne _loop
    end

    cpx ZPKERNAL_CMP0
    if_eq_then
        jsr L1B77                                           ; May throw EXCEPTION_OUT_OF_MEMORY
        sta L272B
        lda ZPKERNAL_CMP0
        jsr L26AB
        ldx ZPKERNAL_CMP0
        lda V37D9,x
        sta ZPBASIC_VALTYP
        lda V37E3,x
        sta T4F
        lda V37ED,x
        sta T50
        lda V37F7,x
        sta P38
        lda V3801,x
        sta P39
        lda # 0
        sta T5A
    else_end

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc L272C
    pha
    tax
    lda V37D9,x
    if_eq_then
        jsr L1B77                                           ; May throw EXCEPTION_OUT_OF_MEMORY
        if_cs_then
            pla
            rts
        else_end

        sta L272B
    else_end

    ldx ZPKERNAL_CMP0
    if_pl_then
        lda ZPBASIC_VALTYP
        sta V37D9,x
        lda T4F
        sta V37E3,x
        lda T50
        sta V37ED,x
        lda P38
        sta V37F7,x
        lda P39
        sta V3801,x
    else_end

    pla
    sta ZPKERNAL_CMP0
    tax
    lda V37D9,x
    if_eq_then
        txa
        pha
        jsr L26AB
        pla
        tax
        lda V37D9,x
    else_end

    sta ZPBASIC_VALTYP
    lda V37E3,x
    sta T4F
    lda V37ED,x
    sta T50
    lda V37F7,x
    sta P38
    lda V3801,x
    sta P39
    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_NO_MORE_FREE_FILES
;;; changed: ...
.proc L2784
    sta L2808
    from
        lda # <V37B1
        sta TFB
        lda # >V37B1
        sta TFC
        lda # <BUFFER_NAME_TABLE
        sta PFD
        lda # >BUFFER_NAME_TABLE
        sta PFE
        ldx # 0
    loop
        stx L2807
        lda # $FF
        jsr STRING_COMPARE_SIGNIFICANT
        bne L27B2
        ldx L2807
        cpx # 2
        bcs L27AD
        L27AA:
        txa
        clc
        rts
        L27AD:
        lda V37D9,x
        bne L27AA
        L27B2:
        lda PFD
        clc
        adc # 8
        sta PFD
        bcc L27BD
        inc PFE
        L27BD:
    next
        ldx L2807
        inx
        cpx # 10
        bne _loop
    end

    lda L2808
    if_eq_then
        sec
        rts
    else_end

    from
        ldx # 2
    loop
        lda V37D9,x
        beq L27E1
        inx
        cpx # 10
        bne _loop
    end

    ; Show "no more free files"
    ldx # <RESOURCE_STRING_NO_MORE_FREE_FILES
    ldy # >RESOURCE_STRING_NO_MORE_FREE_FILES
    jsr PRINT_STATUS_LINE
    sec
    rts

    L27E1:
    stx L2807
    from
        txa
        ; A := 8 * A
        asl
        asl
        asl
        adc # <BUFFER_NAME_TABLE
        sta TFB
        lda # 0
        adc # >BUFFER_NAME_TABLE
        sta TFC
        ldy # 0
    loop
        lda V37B1,y
        sta [TFB],y
    next
        iny
        cpy # BUFFER_NAME_TABLE_ENTRY_SIZE - 1               ; -1 because of '\0'
        bne _loop
    end

    lda     # 0
    sta     [TFB],y
    lda     L2807
    clc
    rts
.endproc

;;; summary: Command: List buffers
;;; changed: ...
.proc CMD_LIST
    lda # PETSCII_CLR
    jsr KERNAL_CHROUT
    jsr L1A89
    ;--lda # PETSCII_BLACK
    ;--jsr KERNAL_CHROUT
 
    ; Show header
    ldx # <RESOURCE_STRING_LIST_HEADER
    ldy # >RESOURCE_STRING_LIST_HEADER
    jsr L293D
    from
        lda # <BUFFER_NAME_TABLE
        sta T5C
        lda # >BUFFER_NAME_TABLE
        sta T5D
        ldx # 0
    loop
        stx L2807
        cpx ZPKERNAL_CMP0
        if_eq_then
            lda ZPBASIC_VALTYP
            jmp _end
        else
            lda V37D9,x
        end

        if_ne_then
            pha
            ldx T5C
            ldy T5D
            jsr L293D
            from_loop
                lda # PETSCII_SPACE
                jsr KERNAL_CHROUT
            next
                iny
                cpy # PETSCII_RETURN
                bne _loop
            end

            pla
            jsr L1FFE
            jsr A_TO_DECIMAL_3_A_X_Y
            jsr KERNAL_CHROUT
            txa
            jsr KERNAL_CHROUT
            tya
            jsr KERNAL_CHROUT
            lda # PETSCII_RETURN
            jsr KERNAL_CHROUT
        else_end

        lda T5C
        clc
        adc # BUFFER_NAME_TABLE_ENTRY_SIZE
        sta T5C
        if_cs_then
            inc T5D
        else_end
    next
        ldx L2807
        inx
        cpx # BUFFER_NAME_TABLE_ENTRY_COUNT
        bne _loop
    end

    ; Show footer
    ldx # <RESOURCE_STRING_LIST_FOOTER
    ldy # >RESOURCE_STRING_LIST_FOOTER
    jsr L293D
    lda ZP_0E
    jsr L1FFE
    jsr A_TO_DECIMAL_3_A_X_Y
    jsr KERNAL_CHROUT
    txa
    jsr KERNAL_CHROUT
    tya
    jsr KERNAL_CHROUT
    ; Show "hit return to continue"
    ldx # <RESOURCE_STRING_HIT_RETURN_TO_CONTINUE
    ldy # >RESOURCE_STRING_HIT_RETURN_TO_CONTINUE
    jsr PRINT_STATUS_LINE
    jsr L1A89

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L293D
    from
        stx T5E
        sty T5F
        ldy # 0
    loop
        lda [T5E],y
        beq _end                                            ; break
        jsr KERNAL_CHROUT
    next
        iny
        bne _loop
    end

    rts
.endproc

;;; summary: A to decimal string representation in A (10^2) X (10^1) Y (10^0)
;;; parameters: A
;;; return: A, X, Y
.proc A_TO_DECIMAL_3_A_X_Y
    from
        ldx # PETSCII_SPACE
        ldy # PETSCII_SPACE
    loop
        sec
        sbc # 100
        bcc _end
        cpx # PETSCII_SPACE
        if_eq_then
            ldx # PETSCII_DIGIT_ZERO
            ldy # PETSCII_DIGIT_ZERO
        else_end
    next
        inx
        jmp _loop
    end

    adc # 100
    from_loop
        sec
        sbc # 10
        bcc _end                                            ; break
        cpy # PETSCII_SPACE
        if_eq_then
            ldy # PETSCII_DIGIT_ZERO
        else_end
    next
        iny
        jmp _loop
    end

    adc # 10 + PETSCII_DIGIT_ZERO
    sty L297F
    tay
    txa
    ldx L297F

    rts
.endproc

;;; summary: Command: Enter command mode
;;; throws: RESOURCE_STRING_INVALID_COMMAND
;;; changed: ...
.proc CMD_COMMAND_MODE
    from_loop
        ; Show "cmd: " on command line
        ldx # <RESOURCE_STRING_COMMAND_PROMPT
        ldy # >RESOURCE_STRING_COMMAND_PROMPT
        jsr L2426
        lda V378E
        if_eq_then
            jsr L2545
            rts
        else_end

        if
            cmp # PETSCII_LATIN_LETTER_A
            bcc _then
            cmp # PETSCII_LATIN_LETTER_Z + 1
            bcc _end
        then
            jsr L2D74
            rts
        else_end

        from
            lda # <COMMAND_NAME_TABLE
            sta TFB
            lda # >COMMAND_NAME_TABLE
            sta TFC
            lda # <V378E
            sta PFD
            lda # >V378E
            sta PFE
            ldx # 0
        loop
            stx T_COMMAND_INDEX
            lda COMMAND_NAME_SIGNIFICANT_CHAR_COUNT,x
            jsr STRING_COMPARE_SIGNIFICANT
            beq EXECUTE_COMMAND
            lda TFB
            clc
            adc # COMMAND_NAME_LENGTH
            sta TFB
            if_cs_then
                inc TFC
            else_end
        next
            ldx T_COMMAND_INDEX
            inx
            cpx # COMMAND_COUNT
            bne _loop
        end

        ; Command not found
        ; Show "invalid command"
        ldx # <RESOURCE_STRING_INVALID_COMMAND
        ldy # >RESOURCE_STRING_INVALID_COMMAND
        jsr PRINT_STATUS_LINE
    next
        jmp _loop
    end

    ; Does not come here
    brk
.endproc

;;; summary: execute command with index in T_COMMAND_INDEX
;;; changed: ...
.proc EXECUTE_COMMAND
    ldx T_COMMAND_INDEX
    lda COMMAND_ADDR_TABLE_LO,x
    sta DL
    lda COMMAND_ADDR_TABLE_HI,x
    sta DH
    jsr JSR_INDIRECT_DX
    jsr L21A2

    ; Need jmp here else CMD_QUIT will not work after another command
    jmp CMD_COMMAND_MODE
    ;jsr CMD_COMMAND_MODE
    ;rts
.endproc

;;; summary: Command: Clear current buffer
;;; throws: EXCEPTION_NO_MORE_FREE_FILES
.proc CMD_CLEAR
    lda # MODE_EDIT
    sta G_MODE
    lda V37B1
    if_eq_then
        sta P38
        sta P39
        lda ZPKERNAL_CMP0
        jmp _end
    else
        lda # 0
        jsr L2784                                           ; May throw EXCEPTION_NO_MORE_FREE_FILES
        if_cs_then
            rts
        else_end
        cmp # 1
        if_eq_then
            rts
        else_end
    end

    jsr L26DA

    rts
.endproc

;;; summary: Command: Goto buffer
;;; throws: EXCEPTION_NO_MORE_FREE_FILES
;;; changed: ...
.proc CMD_GOTO
    lda V37B1
    if_eq_then
        rts
    else_end

    lda # 1
    jsr L2784                                               ; May throw EXCEPTION_NO_MORE_FREE_FILES
    if_cs_then
        rts
    else_end

    cmp ZPKERNAL_CMP0
    if_eq_then
        rts
    else_end

    cmp # BUFFER_INDEX_PASTE
    if_eq_then
        ; User may not go to "paste" edit buffer.
        rts
    else_end

    jsr L272C
    lda # MODE_EDIT
    sta G_MODE
    lda # $0C                                                ; ?
    sta T5A
    lda # $27                                                ; ?
    sta T5B

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_DRIVE_NOT_PRESENT
;;; changed: ...
.proc L2AB7
    pha
    ; Close disk command channel
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    ; Open disk command channel
    lda # DISK_CMD_FH
    ldx ZPKERNAL_FA                                         ; Last used serial device
    ldy # DISK_CMD_SA
    jsr KERNAL_SETLFS
    lda # 0
    jsr KERNAL_SETNAM                                       ; Disk command has no name
    jsr KERNAL_OPEN
    ; Open disk data
    lda # SERIAL_DATA_FH
    ldx ZPKERNAL_FA
    ldy # SERIAL_DATA_DOC_SA
    jsr KERNAL_SETLFS

    from
        ldy # 0
    loop
        lda V37B1,y
        beq _end                                            ; break
    next
        iny
        jmp _loop
    end

    pla
    if_ne_then
        dey
        dey
        lda V37B1,y
        iny
        iny
        cmp # PETSCII_COMMA
        if_ne_then
            lda # PETSCII_COMMA
            sta V37B1,y
            iny
            lda # PETSCII_LATIN_LETTER_S
            sta V37B1,y
            iny
        else_end

        lda # PETSCII_COMMA
        sta V37B1,y
        iny
        lda # PETSCII_LATIN_LETTER_W
        sta V37B1,y
        iny
    else_end

    tya
    ldx # <V37B1
    ldy # >V37B1
    jsr KERNAL_SETNAM
    jsr KERNAL_OPEN
    if_cs_then
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        lda # DISK_CMD_FH
        jsr KERNAL_CLOSE
        ldx # <RESOURCE_STRING_DRIVE_NOT_PRESENT
        ldy # >RESOURCE_STRING_DRIVE_NOT_PRESENT
        pla
        pla
        jsr PRINT_STATUS_LINE

        rts
    else_end

    jsr READ_DISK_STATUS

    rts
.endproc

;;; summary: Command: Get (load) file
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc CMD_GET
    lda # MODE_EDIT
    sta G_MODE
    lda V37B1
    if_eq_then
        rts
    else_end

    lda # 0
    jsr L2AB7
    if_cs_then
        ; Error
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        jsr KERNAL_CLRCHN
        jsr L2C3F

        rts
    else_end

    jsr L1BCB
    ldx # SERIAL_DATA_FH
    jsr KERNAL_CHKIN
    try
        from_loop
            jsr KERNAL_CHRIN
            jsr L1AE4                                       ; May throw EXCEPTION_OUT_OF_MEMORY
            if_cs_then
                jsr L1C99                                   ; A- X- Y-
                if_cc_then
                    jsr L1BBC
                    cmp # PETSCII_RETURN
                    if_ne_then
                        jsr L1BF7
                        lda # PETSCII_RETURN
                        jsr L1AE4                           ; May throw EXCEPTION_OUT_OF_MEMORY
                    else_end
                else_end

                jmp _catch
            else_end

            jsr L1B9C
        next
            jsr KERNAL_READST
            and # KERNAL_IO_EOI
            beq _loop
        end
    catch_finally_end

    ; End of input
    lda # SERIAL_DATA_FH
    jsr KERNAL_CLOSE
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    jsr KERNAL_CLRCHN
    jsr L1C99                                               ; A- X- Y-
    if_cc_then
        jsr L1BBC
        cmp # PETSCII_RETURN
        if_ne_then
            jsr L1B9C
            lda # PETSCII_RETURN
            jsr L1AE4                                       ; May throw EXCEPTION_OUT_OF_MEMORY
        else_end
    else_end

    jsr L1BD6

    rts
.endproc

;;; summary: Command: Put (save) file
;;; changed: ...
.proc CMD_PUT
    lda V37B1
    if_eq_then
        rts
    else_end

    lda # 1
    jsr L2AB7
    if_cs_then
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        lda # DISK_CMD_FH
        jsr KERNAL_CLOSE
        jsr KERNAL_CLRCHN
        jsr L2C3F

        rts
    else_end

    jsr L1BCB
    lda ZPBASIC_VALTYP
    sta T4F
    lda # 3
    sta T50
    ldx # SERIAL_DATA_FH
    jsr KERNAL_CHKOUT
    from_loop
        jsr L1BBC
        bcs _end
        jsr KERNAL_CHROUT
        jsr L1B9C
    next
        jmp _loop
    end

    jsr L1BD6
    lda # SERIAL_DATA_FH
    jsr KERNAL_CLOSE
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    jsr KERNAL_CLRCHN

    rts
.endproc

;;; summary compare [TFB] with [PFD] with A significant characters
;;; changed: ...
.proc STRING_COMPARE_SIGNIFICANT
    tax
    from
        ldy # 0
    loop
        lda [TFB],y
        cmp [PFD],y
        if_ne_then
            ;beq L2C0C
            rts
        else_end

        iny
        cmp # 0
        beq _end                                            ; break
    next
        dex
        bne _loop
    end

    rts
.endproc

;;; summary: Read disk status line to V380B
;;; return: CC=OK , CS=FAIL
;;; changed: A+ X+ Y+
.proc READ_DISK_STATUS
    ldx # DISK_CMD_FH
    jsr KERNAL_CHKIN
    from
        ldy # 0
    loop
        jsr KERNAL_CHRIN
        cmp # PETSCII_RETURN
        beq _end                                            ; break
        sta V380B,y
    next
        iny
        jmp _loop
    end

    lda # 0
    sta V380B,y
    lda V380B
    ora V380B + 1
    cmp # PETSCII_DIGIT_ZERO
    if_eq_then
        ; OK (no error)
        clc
        jmp _end
    else
        ; ERROR
        sec
    end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2C3F
    ldx # <V380B
    ldy # >V380B
    jsr PRINT_STATUS_LINE

    rts
.endproc

;;; summary: Command: Show disk directory
;;; changed: ...
.proc CMD_DIR
    ; Close disk command channel
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    ; Open disk command channel
    lda # DISK_CMD_FH
    ldx ZPKERNAL_FA
    ldy # DISK_CMD_SA
    jsr KERNAL_SETLFS
    lda # 0
    jsr KERNAL_SETNAM                                       ; Disk command does not have a name
    jsr KERNAL_OPEN
    ; open disk data
    lda # SERIAL_DATA_FH
    ldx ZPKERNAL_FA
    ldy # 0
    jsr KERNAL_SETLFS
    lda # 1                                                 ; Length of directory "$"
    ldx # <RESOURCE_STRING_DIR_NAME
    ldy # >RESOURCE_STRING_DIR_NAME
    jsr KERNAL_SETNAM
    jsr KERNAL_OPEN
    jsr READ_DISK_STATUS
    if_cs_then
        lda # SERIAL_DATA_FH
        jsr KERNAL_CLOSE
        lda # DISK_CMD_FH
        jsr KERNAL_CLOSE
        jsr L2C3F
        rts
    else_end

    lda # PETSCII_CLR
    jsr KERNAL_CHROUT
    jsr L1A89
    ;--lda # PETSCII_BLACK
    ;--jsr KERNAL_CHROUT
    ldx # SERIAL_DATA_FH
    jsr KERNAL_CHKIN
    jsr KERNAL_CHRIN
    jsr KERNAL_CHRIN

    try
        from_loop
            jsr L2D27
            bcs _end                                        ; break
            jsr L2D27
            bcs _end                                        ; break
            jsr L2D27
            bcs _end                                        ; break
            pha
            jsr L2D27
            tay
            pla
            tax
            jsr INT_TO_STRING
            from
                ldx # 0
            loop
                lda INT_TO_STRING_RESULT,x
                cmp # PETSCII_SPACE
                beq _end                                    ; break
                jsr KERNAL_CHROUT
            next
                inx
                cpx # 3
                bne _loop
            end

            lda # PETSCII_SPACE
            jsr KERNAL_CHROUT

            from_loop
                jsr L2D27
                bcs _catch                                  ; throw
                cmp # 0
                beq _end                                    ; break
                jsr KERNAL_CHROUT
            next
                jmp _loop
            end

            lda # PETSCII_RETURN
            jsr KERNAL_CHROUT
            from_loop
                lda ZPKERNAL_SFDX                           ; Matrix code of key currently being pressed. Values: $00-$3F: Keyboard matrix code. $40: No key is currently pressed.
                eor # $40
                ora KVAR_SHFLAG                             ; Shift key indicator. Bits: Bit #0: 1 = One or more of left Shift, right Shift or Shift Lock is currently being pressed or locked. Bit #1: 1 = Commodore is currently being pressed. Bit #2: 1 = Control is currently being pressed.
            next
                bne _loop
            end
        next
            jmp _loop
        end
    catch_finally_end

    lda #PETSCII_RETURN
    jsr KERNAL_CHROUT
    jsr KERNAL_CLRCHN
    lda # SERIAL_DATA_FH
    jsr KERNAL_CLOSE
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    ; Clear keyboard buffer
    lda # 0
    sta ZPKERNAL_NDX                                        ; Length of keyboard buffer. Values: $00, 0: Buffer is empty. $01-$0A, 1-10: Buffer length.
    jsr L1A7F
    ; Show "hit return to continue"
    ldx # <RESOURCE_STRING_HIT_RETURN_TO_CONTINUE
    ldy # >RESOURCE_STRING_HIT_RETURN_TO_CONTINUE
    jsr PRINT_STATUS_LINE
    jsr L1A89

    rts
.endproc

;;; summary: read byte from IN
;;; return:
;;;    C: 0=OK , 1=FAIL
;;;    A: byte if CC
.proc L2D27
    jsr KERNAL_READST
    cmp # 0
    if_ne_then
        sec
        rts
    else_end

    jsr KERNAL_CHRIN
    clc

    rts
.endproc

;;; summary: Send disk command
;;; changed: ...
.proc CMD_DISK
    lda # DISK_CMD_FH
    ldx ZPKERNAL_FA
    ldy # DISK_CMD_SA
    jsr KERNAL_SETLFS
    lda # 0                                                 ; Disk command has no name
    jsr KERNAL_SETNAM
    jsr KERNAL_OPEN
    lda V37B1
    if_ne_then
        ldx # DISK_CMD_FH
        jsr KERNAL_CHKOUT
        from
            ldx # 0
        loop
            lda V37B1,x
            beq _end                                        ; break
            jsr KERNAL_CHROUT
        next
            inx
            bne _loop
        end

        jsr KERNAL_CLRCHN
    else_end

    jsr READ_DISK_STATUS
    php
    jsr KERNAL_CLRCHN
    lda # DISK_CMD_FH
    jsr KERNAL_CLOSE
    plp
    if_cs_then
        jsr L2C3F
        rts
    else_end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2D74
    from
        lda # 0
        sta V38AF
        sta V38AD
        ldy # 1
        ldx # 0
    loop
        lda V378E,y
        cmp # CMD_KEY_SEARCH_DOWN
        if_eq_then
            stx V38AB
            jsr CMD_SEARCH_DOWN
            rts
        else_end

        cmp # CMD_KEY_SEARCH_UP
        if_eq_then
            stx V38AB
            jsr CMD_SEARCH_UP
            rts
        else_end
    next
        cmp V378E
        beq _end
        sta V386F,x
        iny
        inx
        bne _loop
    end

    from
        inc V38AF
        stx V38AB
        iny
        ldx # 0
    loop
        lda V378E,y
        cmp # CMD_KEY_SEARCH_DOWN
        if_eq_then
            stx V38AC
            jsr CMD_SEARCH_DOWN
            rts
        else_end

        cmp # CMD_KEY_SEARCH_UP
        if_eq_then
            stx V38AC
            jsr CMD_SEARCH_UP
            rts
        else_end

        cmp V378E
        beq _end                                            ; break
        sta V388D,x
    next
        iny
        inx
        bne _loop
    end

    from
        inc V38AD
        stx V38AC
    loop
        iny
        lda V378E,y
        cmp # CMD_KEY_SEARCH_DOWN
        if_eq_then
            jsr CMD_SEARCH_DOWN
            rts
        else_end

        cmp # CMD_KEY_SEARCH_UP
        if_eq_then
            jsr CMD_SEARCH_UP
            rts
        else_end
    next
        bne _loop
    end
.endproc

;;; summary: Command: Search downward
;;; throws: EXCEPTION_SEARCH_STRING_NOT_FOUND
;;; changed: ...
.proc CMD_SEARCH_DOWN
    ldx # <DO_SEARCH_DOWN
    ldy # >DO_SEARCH_DOWN
    jsr DO_SEARCH

    rts
.endproc

;;; summary: Command: Search upward
;;; throws: EXCEPTION_SEARCH_STRING_NOT_FOUND
;;; changed: ...
.proc CMD_SEARCH_UP
    ldx # <DO_SEARCH_UP
    ldy # >DO_SEARCH_UP
    jsr DO_SEARCH

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_SEARCH_STRING_NOT_FOUND
;;; changed: ...
.proc DO_SEARCH
    stx DL
    sty DH

    lda V38AB
    if_eq_then
        rts
    else_end

    from
        lda # 0
        sta V38AE
    loop
        jsr JSR_INDIRECT_DX
        bcc _end                                            ; break
        lda # 1
        sta V38AE
        lda V38AF
        beq _end                                            ; break
        bit G_MODE
        bmi _end                                            ; G_MODE = MODE_SELECT -> break
        ; G_MODE = MODE_EDIT
        jsr L2E4D
        bcs _end                                            ; break
    next
        lda V38AD
        bne _loop
    end

    lda V38AE
    if_eq_then
        jsr L2F91                                           ; May throw EXCEPTION_SEARCH_STRING_NOT_FOUND
        rts
    else_end

    lda V38AF
    if_ne_then
        bit G_MODE
        if_pl_then
            ; G_MODE = MODE_EDIT
            ldx V38AC
            if_ne_then
                from_loop
                    dex
                    beq _end
                    jsr L1C99                               ; A- X- Y-
                next
                    jmp _loop
                end
            else_end
        else_end
    else_end

    lda # $0C                                                ; ?
    sta T5A
    lda # $23                                                ; ?
    sta T5B
    jsr L21A2

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_OUT_OF_MEMORY
;;; changed: ...
.proc L2E4D
    from
        ldx V38AB
    loop
        jsr L1BF7
    next
        dex
        bne _loop
    end

    lda V38AC
    if_ne_then
        from
            ldx # 0
        loop
            lda V388D,x
            jsr L1AE4                                       ; May throw EXCEPTION_OUT_OF_MEMORY
            if_cs_then
                rts
            else_end

            jsr L1B9C
        next
            inx
            cpx V38AC
            bne _loop
        end

        jsr L1C99                                           ; A- X- Y-
    else_end

    clc

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc DO_SEARCH_DOWN
    lda L1CE7
    pha
    lda L1CE8
    pha
    lda P38
    pha
    lda P39
    pha

    try
        from
            jsr L1BCB
            ldy # 0
        loop
            jsr L1BBC
            cmp # PETSCII_RETURN
            if_eq_then
                bit G_MODE
                if_mi_then
                    ; G_MODE = MODE_SELECT
                    inc L1CE7
                    if_eq_then
                        inc L1CE8
                    else_end
                else_end

                inc P38
                if_eq_then
                    inc P39
                else_end
            else_end

            jsr L1B9C
            cpy V38AB
            if_eq_then
                pla
                pla
                pla
                pla
                jsr L2EDD
                sec
                rts
            else_end

            jsr L1BBC
            bcs _catch
            cmp V386F,y
            if_eq_then
                iny
                jmp _end
            else
                cpy # 0
                if_ne_then
                    jsr L2EDD
                else_end
            end
        next
            jmp _loop
        end
    catch_finally_end

    pla
    sta P39
    pla
    sta P38
    pla
    sta L1CE8
    pla
    sta L1CE7
    jsr L1BD6
    clc

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2EDD
    from_loop
        jsr L1C99                                           ; A- X- Y-
        jsr L1BBC
        cmp # PETSCII_RETURN
        if_eq_then
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                lda L1CE7
                if_eq_then
                    dec L1CE8
                else_end

                dec L1CE7
            else_end

            lda P38
            if_eq_then
                dec P39
            else_end

            dec P38
        else_end
    next
        dey
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc DO_SEARCH_UP
    ldy V38AB
    dey
    jsr L1BCB
    lda L1CE7
    pha
    lda L1CE8
    pha
    lda P38
    pha
    lda P39
    pha

    try
        from_loop
            jsr L1C99                                       ; A- X- Y-
            bcs _catch
            jsr L1BBC
            cmp # PETSCII_RETURN
            if_eq_then
                bit G_MODE
                if_mi_then
                    ; G_MODE = MODE_SELECT
                    lda L1CE7
                    if_eq_then
                        dec L1CE8
                    else_end

                    dec L1CE7
                else_end

                lda P38
                if_eq_then
                    dec P39
                else_end

                dec P38
            else_end

            cmp V386F,y
            if_eq_then
                dey
                if_mi_then
                    pla
                    pla
                    pla
                    pla
                    sec
                    rts
                else_end

                jmp _end
            else
                iny
                cpy V38AB
                if_ne_then
                    jsr L2F6D
                else_end

                dey
            end
        next
            jmp _loop
        end
    catch_finally_end

    pla
    sta P39
    pla
    sta P38
    pla
    sta L1CE8
    pla
    sta L1CE7
    jsr L1BD6
    clc

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L2F6D
    from_loop
        jsr L1BBC
        cmp # PETSCII_RETURN
        if_eq_then
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                inc L1CE7
                if_eq_then
                    inc L1CE8
                else_end
            else_end

            inc P38
            if_eq_then
                inc P39
            else_end
        else_end

        jsr L1B9C
    next
        iny
        cpy V38AB
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; throws: EXCEPTION_SEARCH_STRING_NOT_FOUND
;;; changed: ...
.proc L2F91
    ldx # <RESOURCE_STRING_SEARCH_STRING_NOT_FOUND
    ldy # >RESOURCE_STRING_SEARCH_STRING_NOT_FOUND
    jsr PRINT_STATUS_LINE

    rts
.endproc

;;; summary: Initialize
;;; changed: A, X, Y, ...
.proc INITIALIZE

    lda # CPU_P_V
    sta ZP_BIT_V

    ; Clear any exception
    clv

    ; Set all keys repeat
    lda # $80                                               ; All keys repeat
    sta KVAR_RPTFLG                                         ; Keyboard repeat switch. Bits: Bits #6-#7: %00 = Only cursor up/down, cursor left/right, Insert/Delete and Space repeat; %01 = No key repeats; %1x = All keys repeat.
    ; A = $80 , X = ? Y = ?
    ;
    ldy # 0
    sty ZP_EXCEPTION_CODE                                   ; EXCEPTION_NONE
    sty G_MODE                                              ; MODE_EDIT
    sty T22
    sty T26
    sty P38
    sty P39
    sty T4E
    sty T5A
    sty T5B
    sty L1CE9
    sty L1CEA
    sty V38AB

    ; Initialize edit buffers: First byte of page points to page of next block.
    sei
        lda # CPU_PORT_DATA_BASIC_RAM_IO_RAM_KERNAL_RAM_DATASETTE_DEFAULT
        sta CPU_PORT_DATA
        ; A = ? , X = ? Y = $00
            from
                lda # EDIT_BUFFERS_1_FIRST_PAGE
                ; A = EDIT_BUFFERS_1_FIRST_PAGE , X = ? Y = $00
                sta ZP_0E
                ; [ZP_0E] = EDIT_BUFFERS_1_FIRST_PAGE
            loop
                sta T4F
                clc
                adc # 1
                cmp # EDIT_BUFFERS_1_LAST_PAGE + 1
                if_eq_then
                    ; A = EDIT_BUFFERS_1_LAST_PAGE + 1
                    ;bne L3002
                    lda # EDIT_BUFFERS_2_FIRST_PAGE
                    ; A = EDIT_BUFFERS_2_FIRST_PAGE
                else_end
                sta [T4E],y
            next
                cmp # EDIT_BUFFERS_2_LAST_PAGE
                bne _loop
            end
            ; A = EDIT_BUFFERS_2_LAST_PAGE , X = ? , Y = 0

        lda # CPU_PORT_DATA_BASIC_RAM_IO_AREA_KERNAL_ROM_DATASETTE_DEFAULT
        sta CPU_PORT_DATA
    cli

    ; Now BASIC is RAM, IO is devices, Kernal is ROM

    ; A = ? , X = ? , Y = 0
    ; T4E = $00
    ; T4F = EDIT_BUFFERS_2_LAST_PAGE
    ; Set last page in edit buffer 2 next page pointer to 0
    ;sty VBF00
    tya
    ; A = 0 , X = ? , Y = 0
    sta [T4E],y
    ; [EDIT_BUFFERS_2_LAST_PAGE#0] = 0
    ;
    from
        ;lda # 0
        ldx # EDIT_BUFFER_COUNT - 1
    loop
        sta V37D9,x
    next
        dex
        bpl _loop
    end
    ; A = $00 , X = $FF , Y = $00
    ;
    stx ZPKERNAL_CMP0

    jsr L272C
    jsr L1A89
    jsr L21A2
    ;
    .if ::FEATURE_ARG = 1
        ; Process arguments, if any: load file.
        lda SHELL_ARGC
        cmp # 2
        if_eq_then
            ; argc == 2, i.e. argv = [ "ED" , "FILE" ]
            ; T5C#T5D := SHELL_ARGV[1]
            clc
            lda SHELL_ARGV_LO
            adc # SIZEOF_ADDR                               ; get argv[1] 
            sta T5C
            lda SHELL_ARGV_HI
            adc # 0
            sta T5D
            ; T5C#T5D := *argv[1]
            ldy # 0                                         ; Y = 0
            lda [T5C],y
            tax
            iny                                             ; Y = 1
            lda [T5C],y
            sta T5D
            stx T5C
            dey                                             ; Y = 0
            from_loop
                lda [T5C],y
                sta V37B1,y
            next
                iny
                cmp # 0
                bne _loop
            end

            ; Load
            jsr CMD_GET

            jsr L21A2
        else_end
    .endif

    rts
.endproc

;;; summary: Command: Quit
;;; changed: ...
.proc CMD_QUIT
    ; Jump to BASIC, basically same as <RUN STOP>+<RESTORE>. Selects BASIC ROM, IO devices, Kernal ROM.
    jmp [KERNAL_CBINV]
        ; Does not return to here.
.endproc

;;; summary: ?
;;; changed: A+ X+ Y+
.proc SCROLL_RIGHT
    from
        lda # <OUR_VIDEO_MATRIX_BASE
        sta TFB
        lda # >OUR_VIDEO_MATRIX_BASE
        sta TFC

        lda P36
        clc
        adc # VIC_CHAR_COLUMNS - 1
        sta ZAB

        lda # 0
        sta Z9E
        sta T5C

        lda V37D7
        sta Z9F
        sta T5D

        ; [Z9E=$00,Z9F] = [L322E=$00,L322F] = [L3223=$00,L3224]

        ldy # 2
        lda [T5C],y
        sta V38B1
        jsr L333B                                           ; A+ L3380+ L337F+

        lda # EDIT_PANEL_FIRST_LINE
        sta PFD                                             ; Screen line index

        ldx V37D8
        stx ZA8                                             ; X = [ZA8]
    loop
        ldy ZA8
        lda [Z9E],y
        if_eq_then
            rts
        else_end

        from
            ldy # 0
            sty ZA9                                         ; Y = [ZA9]
            sty ZAA                                         ; [L3235] = [ZAA]
        loop
            ldy ZA8
            lda [Z9E],y
            cmp # PETSCII_RETURN
            if_eq_then
                lda ZAA
                if_eq_then
                    lda # PETSCII_SPACE
                    pha
                else_end
                
                jmp _end
            else
                ldy ZA9
                cpy ZAB
                if_eq_then
                    jsr L240D                               ; A+, V378D+
                    pha
                    inc ZAA
                else_end

                cpx V38B1
                if_eq_then
                    jsr L3287                               ; A+ X=2 Y-
                    stx ZA8
                else_end
            next
                inx
                inc ZA8
                iny
                inc ZA9
                jmp _loop
            end
        end

        cpx V38B1
        if_eq_then
            jsr L3287                                       ; A+ X=2 Y-
            stx ZA8
        else_end

        from
            inx
            inc ZA8
            ldy # 1
        loop
            lda [TFB],y
            dey
            sta [TFB],y
        next
            iny
            iny
            cpy # VIC_CHAR_COLUMNS
            bne _loop
        end

        pla
        jsr L3381                                           ; A- X- Y-
        dey
        sta [TFB],y
        lda TFB
        clc
        adc # VIC_CHAR_COLUMNS
        sta TFB
        if_cs_then
            inc TFC
        else_end
    next
        inc PFD
        lda PFD
        cmp # EDIT_PANEL_LAST_LINE + 1
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: A+ X=2 Y-
.proc L3287
    tya
    pha
        ldy # 0
        lda [T5C],y
        sta Z9F
        sta ZB1
        sta T5D
        ldy # 2
        lda [T5C],y
        sta V38B1
        ldx # 2
    pla
    tay
    rts
.endproc

;;; summary: Scroll to the left
;;; changed: A+ X+ Y+
.proc SCROLL_LEFT
    from OUTER_LOOP
        lda # <OUR_VIDEO_MATRIX_BASE
        sta TFB
        lda # >OUR_VIDEO_MATRIX_BASE
        sta TFC

        lda # 0
        sta ZB0
        sta T5C
        lda V37D7
        sta ZB1
        sta T5D
        ldy # 2
        lda [T5C],y
        sta V38B1
        jsr L333B                                           ; A+ L3380+ L337F+
        lda # 0
        sta PFD
        ldx V37D8
        stx Z9C
    loop
        ldy Z9C
        lda [ZB0],y

        if_eq_then
            rts
        else_end

        from INNER_LOOP
            ldy # 0
            sty ZB2
            sty ZB3
        loop
            ldy Z9C
            lda [ZB0],y
            cmp # PETSCII_RETURN
            if_eq_then
                lda ZB2
                if_eq_then
                    lda # PETSCII_SPACE
                    pha
                else_end

                jmp INNER_LOOP::_end                        ; break
            else_end

            ldy ZB3
            cpy P36
            if_eq_then
                jsr L240D                                   ; A+, V378D+
                pha
                inc ZB2
            else_end

            cpx V38B1
            if_eq_then
                jsr L3287                                   ; A+ X=2 Y-
                stx Z9C
            else_end
        next
            inx
            inc Z9C
            iny
            inc ZB3
            jmp _loop
        end
    
        ldx Z9C
        cpx V38B1
        if_eq_then
            jsr L3287                                       ; A+ X=2 Y-
            stx Z9C
        else_end

        inx
        inc Z9C
        from
            ldy # VIC_CHAR_COLUMNS
        loop
            dey
            dey
            bmi _end                                        ; break
            lda [TFB],y
            iny
            sta [TFB],y
        next
            jmp _loop
        end

        pla
        jsr L3381                                           ; A- X- Y-
        iny
        sta [TFB],y
        lda TFB
        clc
        adc # VIC_CHAR_COLUMNS
        sta TFB
        if_cs_then
            inc TFC
        else_end

    next
        inc PFD
        lda PFD
        cmp # EDIT_PANEL_LAST_LINE + 1
        bne _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: A+ L3380+ L337F+
.proc L333B
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda L1CE8
        if_pl_then
            lda T5A
            sta L3380
            sec
            sbc L1CE7
            sta L337F
            lda # 0
            sbc L1CE8
            if_mi_then
                lda # 0
                sta L337F
            else_end

            jmp _end
        else
            lda T5A
            sta L337F
            inc L337F
            sec
            sbc L1CE7
            sta L3380
            inc L3380
            lda # $FF
            sbc L1CE8
            if_pl_then
                lda # $19                                   ; ?
                sta L3380
            else_end
        end
    else_end

    rts
.endproc

;;; summary: ?
;;; changed: A- X- Y-
.proc L3381
    pha
        bit G_MODE
        if_mi_then
            ; G_MODE = MODE_SELECT
            lda PFD
            cmp L337F
            if_cs_then
                cmp L3380
                if_cc_then
                    pla
                    eor # $80                               ; Reverse?
                    pha
                else_end
            else_end
        else_end
    pla

    rts
.endproc

;;; summary: process char in A
;;; in:
;;;   A: character to process (!= 0)
;;; changed: ...
.proc PROCESS_CHAR
BREAK1:
    ; available: X, Y
    ;
    ; $00 - $1F Control characters
    ; $20 - $7F Printable characters
    ; $80 - $9F Control characters
    ; $A0 - $FF Printable characters
    cmp # $80
    if_lt_then
        ; A < $80
        cmp # $20
        if_lt_then
            ; A < $20
            jsr PROCESS_CONTROL_CHAR
            clc
            bcc _end
        else
            ; $20 <= A < 80
            jsr ADD_CHAR
        end
        clc
        bcc _end
    else
        ; A >= $80
        cmp # $A0
        if_lt_then
            ; $80 <= A < $A0
            jsr PROCESS_CONTROL_CHAR
            clc
            bcc _end
        else
            ; $A0 <= A <= $FF
            jsr ADD_CHAR
        end
    end

    rts
.endproc

;;; summary: Process control character
;;; in:
;;;   A: character to process (A >= $01 and A <= $1D) or (A >= $80 and A <= $9F)
;;; changed:
;;;    X , Y
.proc PROCESS_CONTROL_CHAR
    from THE_LOOP
        ldx # 0
    loop
        cmp MAP_KEY_TO_EDIT_CMD,x
        if_lt_then
            ; C=0 , A < MAP_KEY_TO_EDIT_CMD[X]
            ; Not in table
            bcc THE_LOOP::_end                              ; break
        else_end
        ;
        ; C=1 , A >= MAP_KEY_TO_EDIT_CMD[X]
        if_eq_then
            ; C=1 , Z=1 , A = MAP_KEY_TO_EDIT_CMD[X]
            ; Found: X is command index
            ldy CMD_ADDR_TABLE_LO,x
            sty DL
            ldy CMD_ADDR_TABLE_HI,x
            sty DH
            jsr JSR_INDIRECT_DX
            ; A=? X=? Y=? C=? N=? V=? Z=?
            clc
            bcc THE_LOOP::_end                              ; break
        else_end
        ;
        ; C=1 , A != MAP_KEY_TO_EDIT_CMD[X]
        ; continue
    next
        inx
        ldy MAP_KEY_TO_EDIT_CMD,x
        bne _loop
    end

    rts
.endproc

;;; summary: Command: Cursor right
;;; changed: ...
.proc CMD_CURSOR_RIGHT
    lda P35
    cmp Z92
    if_ne_then
        ldx P35
        inx
        stx P35
        stx P19
        jsr L1B9C
        lda T5B
        cmp # BUMP_RIGHT
        if_cs_then
            inc P36
            jsr SCROLL_RIGHT
            jmp L2545
        else_end

        inc T5B
        jsr L2545
    else_end

    rts
.endproc

;;; summary Command: Cursor left
;;; changed: ...
.proc CMD_CURSOR_LEFT
    ldx P35
    cpx P36
    if_cc_then
        stx P19
        dec P36
        jsr SCROLL_LEFT
        rts
    else_end

    cpx # 0
    if_ne_then
        dex
        stx P35
        stx P19
        jsr L1C99                                           ; A- X- Y-
        lda T5B
        cmp # BUMP_LEFT
        if_cc_then
            jsr L19D0
            inx
            cpx T5B
            if_ne_then
                dec P36
                jsr SCROLL_LEFT
                jmp L2545
            else_end
        else_end

        dec T5B
        jsr L2545
    else_end

    rts
.endproc

;;; summary: Command: Cursor up
;;; changed: ...
.proc CMD_CURSOR_UP
    lda T5A
    cmp # BUMP_TOP
    if_cs_then
        jsr MOVE_CURSOR_UP                                  ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
        jmp _end
    else
        jsr L268E
        if_cs_then
            lda T5A
            if_eq_then
                rts
            else_end

            jsr MOVE_CURSOR_UP                              ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
            jmp _end
        else
            jsr L2649
            jsr L23DF
            jsr L351B
        end
    end

    jsr L1BEC
    jsr L19DD
    jsr L1BE1
    ldx P19
    jsr L1A2A
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda L1CE7
        if_eq_then
            dec L1CE8
        else_end

        dec L1CE7
        lda ZPKERNAL_PNT_HI
        sta TFC
        lda L1CE8
        if_pl_then
            lda ZPKERNAL_PNT_LO
            sta TFB
            jmp _end
        else
            lda ZPKERNAL_PNT_LO
            clc
            adc # VIC_CHAR_COLUMNS
            sta TFB
            if_cs_then
                inc TFC
            else_end
        end

        jsr L34F3
    else_end

    lda P38
    if_eq_then
        dec P39
    else_end
 
    dec P38
    jsr L2545

    rts
.endproc

;;; summary: Reverse line @TFB
;;; changed: ...
.proc L34F3
    ldy # VIC_CHAR_COLUMNS - 1
    from_loop
        lda [TFB],y
        eor # $80
        sta [TFB],y
    next
        dey
        bpl _loop
    end

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L34FF
    ldy # 0
    from_loop
        cpy T5A
        beq _end                                            ; break
        jsr L19DD
        bcs _end                                            ; break
    next
        iny
        jmp _loop
    end

    sty T5A
    lda T4F
    sta V37D7
    lda T50
    sta V37D8

    rts
.endproc

;;; summary: ?
;;; changed: ...
.proc L351B
    lda # <OUR_VIDEO_MATRIX_BASE
    sta TFB
    lda # >OUR_VIDEO_MATRIX_BASE
    sta TFC
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda L1CE8
        if_pl_then
            lda T5A
            sec
            sbc L1CE7
            lda # 0
            sbc L1CE8
            if_mi_then
                lda # $80                                   ; ?
                sta L2340
            else_end
        else_end
    else_end

    ldx V37D7
    ldy V37D8
    jsr L2290
    jsr L22B8

    rts
.endproc

;;; summary: Command: Cursor down
;;; changed: ...
.proc CMD_CURSOR_DOWN
    jsr L1BBC
    if_cs_then
        rts
    else_end

    lda T5A
    cmp # BUMP_BOTTOM
    if_cc_then
        jsr MOVE_CURSOR_DOWN                                ; A+ X- Y- ZPKERNAL_PNT_LO+ ZPKERNAL_PNT_HI+ T5A+
        jmp _end
    else
        jsr L23B1
        jsr L2671
        jsr L2627
        if_cc_then
            jsr L199D
            jmp _end
        else
            jsr CLEAR_EDIT_PANEL_LAST_LINE
        end
    end

    jsr L1982
    jsr L1BE1
    ldx P19
    jsr L1A2A
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        lda ZPKERNAL_PNT_HI
        sta TFC
        lda L1CE8
        if_pl_then
            lda ZPKERNAL_PNT_LO
            sec
            sbc # VIC_CHAR_COLUMNS
            sta TFB
            if_cc_then
                dec TFC
            else_end

            jmp _end
        else
            lda ZPKERNAL_PNT_LO
            sta TFB
        end

        jsr L34F3
        inc L1CE7
        if_eq_then
            inc L1CE8
        else_end
    else_end

    inc P38
    if_eq_then
        inc P39
    else_end

    jsr L2545

    rts
.endproc

;;; summary: Command: Page down
;;; changed: ...
.proc CMD_PAGE_DOWN
    lda # PAGE_LINE_COUNT
    sta V38B3
    from_loop
        jsr L1982
        if_cc_then
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                inc L1CE7
                if_eq_then
                    inc L1CE8
                else_end
            else_end

            inc P38
            if_eq_then
                inc P39
            else_end
        else_end
    next
        dec V38B3
        bne _loop
    end

    lda # BUMP_BOTTOM
    sta T5A
    jsr L21A2

    rts
.endproc

;;; summary: Command: Page up
;;; changed: ...
.proc CMD_PAGE_UP
    lda # PAGE_LINE_COUNT
    sta V38B3
    jsr L1BEC
    from_loop
        jsr L19DD
        if_cc_then
            bit G_MODE
            if_mi_then
                ; G_MODE = MODE_SELECT
                lda L1CE7
                if_eq_then
                    dec L1CE8
                else_end
                dec L1CE7
            else_end
            
            lda P38
            if_eq_then
                dec P39
            else_end
            dec P38
        else_end
    next
        dec V38B3
        bne _loop
    end

    lda # BUMP_TOP - 1
    sta T5A
    jsr L21A2

    rts
.endproc

;;; summary: Command: Go top
;;; changed: ...
.proc CMD_GO_TOP
    lda ZPBASIC_VALTYP
    sta T4F
    lda # 3
    sta T50
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        sec
        lda L1CE7
        sbc P38
        sta L1CE7
        lda L1CE8
        sbc P39
        sta L1CE8
    else_end

    lda # 0
    sta P38
    sta P39
    jsr L21A2

    rts
.endproc

;;; summary: Command: Go bottom
;;; changed: ...
.proc CMD_GO_BOTTOM
    from_loop
        jsr L1982
        bcs _end                                            ; break

        bit G_MODE
        if_mi_then
            ; G_MODE = MODE_SELECT
            inc L1CE7
            if_eq_then
                inc L1CE8
            else_end
        else_end

        inc P38
        if_eq_then
            inc P39
        else_end
    next
        bne _loop
    end

    lda # BUMP_BOTTOM
    sta T5A
    jsr L21A2

    rts
.endproc

;;; summary: Command: Go to end of line
;;; changed: ...
.proc CMD_GO_END_LINE
    jsr L1982
    if_cc_then
        jsr L1C99                                           ; A- X- Y-
    else_end
    
    lda # BUMP_RIGHT
    sta T5B
    jsr L219D

    rts
.endproc

;;; summary: Command: Go to begin of line
;;; changed: ...
.proc CMD_GO_BEGIN_LINE
    jsr L1982
    if_cc_then
        jsr L19DD
    else_end

    jsr L219D

    rts
.endproc

;;; summary: Command: Open line
;;; changed: A+ ...
.proc CMD_ADD_LINE
    bit G_MODE
    if_mi_then
        ; G_MODE = MODE_SELECT
        rts
    else_end
    
    ; G_MODE = MODE_EDIT

    jsr L1982
    if_cc_then
        jsr L1C99                                           ; A- X- Y-
    else_end
    
    lda # PETSCII_RETURN
    jsr CMD_SPLIT_LINE

    rts
.endproc

.proc CMD_NOP
    rts
.endproc

;;; summary: Command: Insert
;;; changed: ...
.proc CMD_INSERT
    L366C:  rts
.endproc

.proc CMD_F7
    rts
.endproc

.proc CMD_F8
    rts
.endproc

;;; summary: JSR indirect to [DX]
;;; changed: A- X- Y-
.proc JSR_INDIRECT_DX
    jmp [DX]
    rts
.endproc
